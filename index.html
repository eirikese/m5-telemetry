<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>TrollSports Live v1.5.8</title>
<meta name="theme-color" content="#0b1220"/>
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<style>
  :root{--bg:#0b1220;--card:#0f1a31;--muted:#92a1bd;--text:#e6eefc;--accent:#4cc9f0;--border:#223050;--rec:#ff4d4d}

  /* === Theme tokens (dark default) === */
  :root{
    --theme-color:#0b1220;
    --topbar1:#0a1120;
    --topbar2:#0c1526;
    --btn:#152341;
    --btn-active:#152341;
    --input:#0e1730;
    --chart-text:#dfe7ff;    /* axis labels/ticks/legend */
    --chart-grid:#2a385a;    /* grid lines */
    --leaflet-bg:#0b1220;
  }
  .theme-light{
    --bg:#f7f9fc;
    --card:#ffffff;
    --muted:#4e5d79;
    --text:#0b1220;
    --accent:#1e66f5;
    --border:#d6deeb;
    --theme-color:#ffffff;
    --topbar1:#ffffff;
    --topbar2:#f6f7fb;
    --btn:#f2f6ff;
    --btn-active:#e6effe;
    --input:#f8fbff;
    --chart-text:#22324f;   /* darker ticks for light bg */
    --chart-grid:#c6d3ea;   /* soft grid for light bg */
    --leaflet-bg:#e6eefc;
  }

  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,sans-serif;padding-bottom:env(safe-area-inset-bottom)}
  .topbar{position:sticky;top:0;z-index:10;display:flex;align-items:center;gap:10px;padding:calc(8px + env(safe-area-inset-top)) 12px 8px;background:linear-gradient(180deg,var(--topbar1),var(--topbar2));border-bottom:1px solid var(--border)}
  .app-title{font-weight:700}.spacer{flex:1}.ver{color:var(--muted);font-size:12px}
  .tabs{display:flex;gap:6px}.tabbtn{padding:8px 12px;border-radius:10px;border:1px solid var(--border);background:var(--btn);color:var(--text);cursor:pointer;font-weight:600}
  .tabbtn.active{background:var(--btn-active);border-color:var(--border)}
  .wrap{padding:12px;display:flex;flex-direction:column;gap:12px}.row{display:flex;gap:12px;flex-wrap:wrap;align-items:stretch}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px;box-shadow:0 1px 10px rgba(0,0,0,.2)}
  .grow{flex:1 1 560px}.half{flex:1 1 320px;min-width:300px}
  .small{font-size:12px;color:var(--muted)} .tiny{font-size:11px;color:var(--muted)} .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .num{font-weight:700;font-size:clamp(22px,5.8vw,34px);line-height:1.15}
  .btns{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px} button{padding:10px 14px;border-radius:10px;border:1px solid var(--border);background:var(--btn);color:var(--text);cursor:pointer}
  input,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--text)}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}.hidden{display:none}.ok{color:#16c26e}.bad{color:#ff6b6b}
  .log{font-size:12px;background:var(--input);color:var(--text);padding:10px;border-radius:10px;max-height:200px;overflow:auto;border:1px dashed var(--border)}
  .plot{position:relative;height:45vh;min-height:280px;width:100%} canvas{display:block}
  .recording{background:#4a1111;border-color:#ff7a7a;color:#fff}.recording::before{content:"● ";color:var(--rec)}
  @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(255,77,77,.85)}70%{box-shadow:0 0 0 12px rgba(255,77,77,0)}100%{box-shadow:0 0 0 0 rgba(255,77,77,0)}}
  .blink{animation:pulse 1s infinite}
  .range-row{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center} input[type="range"]{width:100%;accent-color:var(--accent)}
  .unitNow,.unitStats{border-radius:10px;padding:10px;border:1px solid var(--border);background:var(--input)}
  .unitTag{display:inline-block;padding:2px 8px;border-radius:999px;font-weight:700;margin-bottom:6px;color:#000}
  .uNums .num{color:var(--ucolor)}
  #map{height:40vh;min-height:260px;border-radius:12px;overflow:hidden}
  .leaflet-container{background:var(--leaflet-bg)}

  /* Density (KDE) box on Plot tab: stacked plots, full width */
  .dgrid{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px}
  .dens-wrap{
    position:relative;height:200px;border:1px solid var(--border);
    border-radius:8px;padding:6px 6px 4px 6px;background:var(--input);overflow:hidden
  }
  .dens-head{font-size:11px;color:var(--muted);margin:2px 0 4px 2px}
  .dens-wrap canvas{position:absolute;left:0;right:0;bottom:6px;top:22px;width:100% !important;height:auto !important}
</style>
<script src="https://cdn.jsdelivr.net/npm/mqtt/dist/mqtt.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
</head>
<body>
  <div class="topbar">
    <div class="app-title">TrollSports Live</div><div class="spacer"></div>
    <div class="ver">v1.5.8</div>
    <div class="tabs">
      <button class="tabbtn active" data-tab="plot">Plot</button>
      <button class="tabbtn" data-tab="stats">Stats</button>
      <button class="tabbtn" data-tab="settings">Settings</button>
    </div>
  </div>

  <!-- Gate -->
  <div id="gate" class="wrap">
    <div class="card half">
      <div style="font-weight:700;margin-bottom:8px;">Protected dashboard</div>
      <div class="small">Enter site password to unlock. Viewer creds are decrypted in-browser (read-only).</div>
      <label>Site password</label><input id="pw" type="password" placeholder="Enter password"/>
      <div class="btns"><button id="btnUnlock">Unlock</button></div>
      <div id="unlockMsg" class="small"></div>
    </div>
  </div>

  <!-- App -->
  <div id="app" class="wrap hidden">
    <!-- PLOT TAB -->
    <section id="tab-plot">
      <div class="row">
        <div class="card grow" style="align-self:flex-start">
          <div class="plot"><canvas id="chart_ts"></canvas></div>
        </div>
        <div class="card half" id="nowPanel">
          <div style="font-weight:700;margin-bottom:8px;">Now</div>
          <div id="nowUnits" class="grid" style="margin-top:10px;grid-template-columns:1fr;gap:12px"></div>
          <div class="btns" style="margin-top:12px">
            <button id="btnRecord">Start Recording</button>
            <div class="small" id="recInfo" style="align-self:center;margin-left:6px;"></div>
          </div>
        </div>
      </div>
      <div class="row">
      <!-- Distributions by athlete (stacked) -->
        <div class="card grow">
          <div style="font-weight:700;margin-bottom:8px;">Distributions by athlete (window)</div>
          <div class="dgrid">
            <div class="dens-wrap">
              <div class="dens-head">Roll (°) — per athlete</div>
              <canvas id="dist-roll"></canvas>
            </div>
            <div class="dens-wrap">
              <div class="dens-head">Pitch (°) — per athlete</div>
              <canvas id="dist-pitch"></canvas>
            </div>
            <div class="dens-wrap">
              <div class="dens-head">Frequency (Hz) — per athlete</div>
              <canvas id="dist-freq"></canvas>
            </div>
          </div>
          <div class="tiny" style="margin-top:6px;">Roll/Pitch X: −40°…0°…+40°. Frequency X: 0.01–5 Hz. Y: % of that athlete’s peak (0–110%).</div>
        </div>

        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">SOG (knots)</div>
          <div class="plot" style="height:40vh;min-height:260px;"><canvas id="chart_sog"></canvas></div>
          <div class="small" id="sogInfo" style="margin-top:6px;"></div>
        </div>
      </div>

      <div class="row">
        <div class="card grow">
          <div style="font-weight:700;margin-bottom:8px;">GNSS Map</div>
          <div id="map"></div>
          <div class="small" id="mapCredit" style="margin-top:6px;">Basemap © OpenStreetMap, © CARTO — Dark Matter</div>
        </div>
      </div>
    </section>

    <!-- STATS TAB -->
    <section id="tab-stats" class="hidden"><div class="row" id="statsUnits" style="width:100%"></div></section>

    <!-- SETTINGS TAB -->
    <section id="tab-settings" class="hidden">
      <div class="row">
        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Connection</div>
          <div class="grid">
            <div><label>Host</label><input id="host" value="afe7881f82fe42929e4a5370cddc7285.s1.eu.hivemq.cloud"/></div>
            <div><label>WS Port</label><input id="port" value="8884"/></div>
            <div><label>Path</label><input id="path" value="/mqtt"/></div>
            <div><label>Topic</label><input id="topic" value="m5/+/telemetry"/></div>
            <div><label>Client ID (auto)</label><input id="cid" readonly/></div>
            <div><label>Auto-connect after unlock</label><input id="autoconn" type="checkbox" checked/></div>
          </div>
          <div class="small" style="margin-top:8px;">
            Status: <span id="status" class="bad">disconnected</span><br/>
            WSS: <span id="url" class="tiny mono" style="word-break:break-all;"></span>
          </div>
          <div class="btns" style="margin-top:8px">
            <button id="btnConnect">Connect</button>
            <button id="btnDisconnect">Disconnect</button>
            <button id="btnClear">Clear Data</button>
          </div>
        </div>

        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Windows, Peaks & GNSS</div>
          <div class="grid">
            <div style="grid-column:1/-1;">
              <label>Timeseries View Window (seconds)</label>
              <div class="range-row">
                <input id="viewSecRange" type="range" min="5" max="600" step="5" value="30"/>
                <input id="viewSec" type="number" min="5" max="600" step="5" value="30" style="width:90px"/>
              </div>
            </div>
            <div style="grid-column:1/-1;">
              <label>Analysis Window (seconds) — stats & peak detection</label>
              <div class="range-row">
                <input id="winSecRange" type="range" min="5" max="600" step="5" value="30"/>
                <input id="winSec" type="number" min="5" max="600" step="5" value="30" style="width:90px"/>
              </div>
            </div>
            <div><label>Min peak distance (ms)</label><input id="minDist" value="300"/></div>
            <div><label>Min prominence (deg)</label><input id="minProm" value="5.0"/></div>
            <div style="grid-column:1/-1;">
              <label>Velocity smoothing window (seconds)</label>
              <div class="range-row">
                <input id="sogWinRange" type="range" min="3" max="30" step="1" value="8"/>
                <input id="sogWin" type="number" min="3" max="30" step="1" value="8" style="width:90px"/>
              </div>
              <div class="tiny">Speed is computed from a linear fit of XY position over this window (1 Hz GNSS-friendly).</div>
            </div>

            <!-- KDE smoothing controls -->
            <div style="grid-column:1/-1;">
              <label>Distribution smoothing — Roll/Pitch (× bandwidth)</label>
              <div class="range-row">
                <input id="kdeFactorAngRange" type="range" min="0.1" max="1" step="0.1" value="0.3"/>
                <input id="kdeFactorAng" type="number" min="0.1" max="1" step="0.1" value="0.3" style="width:90px"/>
              </div>
            </div>
            <div style="grid-column:1/-1;">
              <label>Distribution smoothing — Frequency (× bandwidth)</label>
              <div class="range-row">
                <input id="kdeFactorFreqRange" type="range" min="0.1" max="1" step="0.1" value="0.3"/>
                <input id="kdeFactorFreq" type="number" min="0.1" max="1" step="0.1" value="0.3" style="width:90px"/>
              </div>
            </div>
            <!-- END KDE -->
          </div>
        </div>

        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Units</div>
          <div id="unitsList" class="grid" style="grid-template-columns:1fr;gap:8px"></div>
        </div>

        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Sync</div>
          <div class="grid">
            <div style="grid-column:1/-1">
              <label>Reference unit</label>
              <select id="syncRef"><option value="auto">Auto (first seen)</option></select>
            </div>
            <div>
              <label>Nearest tolerance (ms)</label>
              <input id="syncTol" type="number" value="120"/>
            </div>
          </div>
          <div class="small" id="syncInfo" style="margin-top:8px;"></div>
        </div>

        <!-- Appearance -->
        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Appearance</div>
          <div class="grid">
            <div style="grid-column:1/-1">
              <label>Theme</label>
              <select id="themeSel">
                <option value="dark">Dark</option>
                <option value="light">Light</option>
                <option value="auto" selected>Auto (match system)</option>
              </select>
            </div>
          </div>
          <div class="tiny" style="margin-top:6px;">Charts, UI, athlete colors, and map tiles adapt for contrast.</div>
        </div>

        <div class="card grow"><div style="font-weight:700;margin-bottom:8px;">Logs</div><pre class="log" id="log"></pre></div>
      </div>
    </section>
  </div>

<script>
const APP_VERSION="v1.5.8";
const ENCRYPTED_CREDS="eyJzYWx0IjoiYU01amVaRG9rd0o5dmVDc1gwTjhoQT09IiwiaXYiOiJuTEdVM2NldmhSSGFVR2ZmIiwiY3QiOiIzeVZaUkxnRUNxaWxicU92QmExZlJkcVZUb1ZiM3NvZFArd2svK3FxTW9NZGRYZHV5V2gveTV3WmVxakZlZkV6L2ZpZjN6SEpqU3Z0TXd2OCJ9";
const $=id=>document.getElementById(id);

// ---------- utilities ----------
function log(s){const el=$('log');el.textContent+=s+"\\n";el.scrollTop=el.scrollHeight}
function setStatus(t,ok=false){$('status').textContent=t;$('status').className=ok?'ok':'bad'}
function meanStd(a){if(!a.length)return{mean:NaN,std:NaN};const m=a.reduce((x,y)=>x+y,0)/a.length;const v=a.reduce((x,y)=>x+(y-m)*(y-m),0)/a.length;return{mean:m,std:Math.sqrt(v)}}
function fmt2(n){return n.toString().padStart(2,'0')}
const b64d=b64=>Uint8Array.from(atob(b64),c=>c.charCodeAt(0));
async function deriveKey(pw,salt){const enc=new TextEncoder();const mat=await crypto.subtle.importKey('raw',enc.encode(pw),'PBKDF2',false,['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},mat,{name:'AES-GCM',length:256},false,['encrypt','decrypt'])}
async function decryptCreds(pass,blob){const j=JSON.parse(atob(blob));const key=await deriveKey(pass,b64d(j.salt));const pt=await crypto.subtle.decrypt({name:'AES-GCM',iv:b64d(j.iv)},key,b64d(j.ct));return JSON.parse(new TextDecoder().decode(new Uint8Array(pt)))}
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

// color helpers (keep hue, darken for light theme)
function hexToRgb(h){h=h.replace('#',''); if(h.length===3){h=h.split('').map(c=>c+c).join('');} const n=parseInt(h,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};}
function rgbToHex({r,g,b}){const f=v=>v.toString(16).padStart(2,'0'); return '#'+f(r)+f(g)+f(b);}
function rgbToHsl({r,g,b}){r/=255;g/=255;b/=255;const max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,l=(max+min)/2;if(max===min){h=s=0;}else{const d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return {h,s,l};}
function hslToRgb({h,s,l}){let r,g,b;if(s===0){r=g=b=l;}else{const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return {r:Math.round(r*255),g:Math.round(g*255),b:Math.round(b*255)};}
function darkenHex(hex, amt=0.22){ // reduce lightness by amt (0..1) — stronger for light mode
  const hsl=rgbToHsl(hexToRgb(hex)); const l=Math.max(0, hsl.l*(1-amt)); return rgbToHex(hslToRgb({...hsl,l}));
}

// ---------- chart defaults ----------
Chart.defaults.color='#dfe7ff'; Chart.defaults.borderColor='#2a385a';

// ---------- theme handling ----------
const THEME_KEY = 'ts_theme'; // 'dark' | 'light' | 'auto'
let _mqLight = window.matchMedia('(prefers-color-scheme: light)');
function currentThemeChoice(){ return localStorage.getItem(THEME_KEY) || 'auto'; }

function applyTheme(choice){
  let mode = choice==='auto' ? (_mqLight.matches?'light':'dark') : choice;
  document.documentElement.classList.toggle('theme-light', mode==='light');

  // update status bar color
  const cs = getComputedStyle(document.documentElement);
  const themeColor = cs.getPropertyValue('--theme-color').trim() || '#ffffff';
  const meta = document.querySelector('meta[name="theme-color"]');
  if(meta) meta.setAttribute('content', themeColor);

  // Chart defaults then per-chart axis ticks/grid
  const chartText = cs.getPropertyValue('--chart-text').trim();
  const chartGrid = cs.getPropertyValue('--chart-grid').trim();
  Chart.defaults.color = chartText;
  Chart.defaults.borderColor = chartGrid;

  const retick = (chart)=>{
    if(!chart) return;
    if(chart.options?.scales?.x){
      chart.options.scales.x.ticks ||= {};
      chart.options.scales.x.grid ||= {};
      chart.options.scales.y ||= {};
      chart.options.scales.y.ticks ||= {};
      chart.options.scales.y.grid ||= {};
      chart.options.scales.x.ticks.color = chartText;
      chart.options.scales.y.ticks.color = chartText;
      chart.options.scales.x.grid.color = chartGrid;
      chart.options.scales.y.grid.color = chartGrid;
    }
    chart.update('none');
  };

  // Map tiles
  const isLight = (mode==='light');
  const url = isLight
    ? 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
    : 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
  const credit = isLight
    ? 'Basemap © OpenStreetMap, © CARTO — Positron'
    : 'Basemap © OpenStreetMap, © CARTO — Dark Matter';

  if(map){
    if(window._tileLayer) map.removeLayer(window._tileLayer);
    window._tileLayer = L.tileLayer(url, {attribution:'&copy; OSM & CARTO', subdomains:'abcd', maxZoom:20});
    window._tileLayer.addTo(map);
  }
  const mc = $('mapCredit'); if(mc) mc.textContent = credit;

  // Re-tint athlete assets (darker in light mode)
  refreshUnitStylesForTheme(mode);

  // Apply tick/grid colors to all charts
  retick(chartTS);
  retick(chartSOG);
  if(distCharts.roll)  retick(distCharts.roll);
  if(distCharts.pitch) retick(distCharts.pitch);
  if(distCharts.freq)  retick(distCharts.freq);
}

function initThemeUI(){
  const sel = $('themeSel');
  if(!sel) return;
  sel.value = currentThemeChoice();
  sel.addEventListener('change', e=>{
    localStorage.setItem(THEME_KEY, e.target.value);
    applyTheme(e.target.value);
  });
  _mqLight.addEventListener?.('change', ()=>{
    if(currentThemeChoice()==='auto') applyTheme('auto');
  });
}

// ---------- state ----------
let client=null, unlocked=false, viewer={user:null,pass:null};
let chartTS=null, chartSOG=null;
let map=null, mapInited=false, firstMapFixDone=false;
let globalT0=null, syncLastMs=null;

// Athlete base palette (unchanged); darker variant applied only in light mode
const COLORS_BASE=["#4cc9f0","#ffd166","#ef476f","#06d6a0","#a78bfa","#7dd3fc","#fca5a5","#86efac"];
function themedColor(hex){ const mode = document.documentElement.classList.contains('theme-light')?'light':'dark'; return (mode==='light') ? darkenHex(hex,0.22) : hex; }

const units={}, discoveredOrder=[];
const MAX_KEEP_SEC=600, FREQ_HOLD_MS=2000, GNSS_KEEP=4000;

// windows
const sogRange=$('sogWinRange'), sogNum=$('sogWin');
function getSogWinSec(){ return clamp(parseInt(sogNum.value||'8',10),3,30); }
sogRange.addEventListener('input',e=>sogNum.value=e.target.value);
sogNum.addEventListener('change',e=>sogRange.value=e.target.value);

// KDE smoothing controls
const kdeAngRange=$('kdeFactorAngRange'), kdeAngNum=$('kdeFactorAng');
const kdeFreqRange=$('kdeFactorFreqRange'), kdeFreqNum=$('kdeFactorFreq');
function getKdeFactorAngles(){ return clamp(parseFloat(kdeAngNum.value||'0.3'),0.1,1); }
function getKdeFactorFreq(){ return clamp(parseFloat(kdeFreqNum.value||'0.3'),0.1,1); }
kdeAngRange.addEventListener('input',e=>{ kdeAngNum.value=e.target.value; updateUnifiedDistributions(); });
kdeAngNum.addEventListener('change',e=>{ kdeAngRange.value=e.target.value; updateUnifiedDistributions(); });
kdeFreqRange.addEventListener('input',e=>{ kdeFreqNum.value=e.target.value; updateUnifiedDistributions(); });
kdeFreqNum.addEventListener('change',e=>{ kdeFreqRange.value=e.target.value; updateUnifiedDistributions(); });

// sync
let syncRefMode='auto';
const syncRefSelect=$('syncRef');
function setSyncRefMode(val){ syncRefMode=val; $('syncInfo').textContent=`Reference: ${val}`; resetSyncSeries(); }
function getRefUnit(){ if(syncRefMode!=='auto' && units[syncRefMode]) return syncRefMode; return discoveredOrder.length? discoveredOrder[0] : null; }

// recording
let recActive=false, recRows=[], recStartedAt=null;

// DOM refs
const nowUnits=$('nowUnits'), statsUnits=$('statsUnits'), unitsList=$('unitsList');

// ---------- chart builders ----------
function makeTimeseries(){
  const ctx=document.getElementById('chart_ts').getContext('2d');
  return new Chart(ctx,{type:'line',data:{datasets:[]},options:{
    animation:false,responsive:true,maintainAspectRatio:false,
    scales:{
      x:{type:'linear',title:{display:true,text:'time (s from start)'},ticks:{callback:v=>Number(v).toFixed(1)}},
      y:{title:{display:true,text:'degrees'},min:-40,max:40}
    },
    plugins:{legend:{position:'bottom'}}
  }});
}
function makeSOG(){
  const ctx=document.getElementById('chart_sog').getContext('2d');
  return new Chart(ctx,{type:'line',data:{datasets:[]},options:{
    animation:false,responsive:true,maintainAspectRatio:false,
    scales:{
      x:{type:'linear',title:{display:true,text:'time (s from start)'},ticks:{callback:v=>Number(v).toFixed(1)}},
      y:{title:{display:true,text:'knots'},min:0,max:8}
    },
    plugins:{legend:{position:'bottom'}}
  }});
}
function makeMap(){
  map=L.map('map',{zoomControl:true});
  window._tileLayer=null; // will be set by applyTheme()
  map.setView([0,0],2); mapInited=true;
}
function fitMapIfFirst(lat,lon){ if(!firstMapFixDone){ map.setView([lat,lon],15); firstMapFixDone=true; } }

// ---------- KDE helpers ----------
function linspace(min,max,n){ const a=new Array(n); const step=(max-min)/(n-1); for(let i=0;i<n;i++) a[i]=min+i*step; return a; }
function stddev(arr){ if(!arr.length) return 0; const m=arr.reduce((s,v)=>s+v,0)/arr.length; return Math.sqrt(arr.reduce((s,v)=>s+(v-m)*(v-m),0)/arr.length); }
function kdeBandwidth(arr){ if(arr.length<2) return 1; const s=stddev(arr); return 1.06*s*Math.pow(arr.length,-1/5); }
function gaussian(u){ return Math.exp(-0.5*u*u)/Math.sqrt(2*Math.PI); }

/* Log-KDE for strictly positive variables */
function kdeOnGridLogBack(values, xs, factor=1){
  const v = (values || []).filter(Number.isFinite).filter(x => x > 0);
  if (!v.length) return xs.map(_ => 0);
  const y = v.map(Math.log);
  let h = kdeBandwidth(y) * factor;
  if (!Number.isFinite(h) || h <= 1e-6) {
    const ymin = Math.min(...y), ymax = Math.max(...y);
    const span = (ymax - ymin) || 1;
    h = Math.max(span * 0.05, 1e-3) * factor;
  }
  const n = y.length;
  const invnh = 1 / (n * h);
  const out = new Array(xs.length);
  for (let j = 0; j < xs.length; j++) {
    const x = Math.max(xs[j], 1e-9);
    const yl = Math.log(x);
    let s = 0;
    for (let i = 0; i < n; i++) s += gaussian((yl - y[i]) / h);
    out[j] = (s * invnh) / x;
  }
  return out;
}

/* NEW: Log-KDE with positive shift → handles negatives.
   We shift both data and evaluation grid by C so everything is >0, do log-KDE, then back-transform.
   f_X(x) = f_Z(x+C), where Z = X + C and f_Z(z) = f_Y(log z) * (1/z)
*/
function kdeOnGridLogBackShift(values, xs, factor=1){
  const v0 = (values || []).filter(Number.isFinite);
  if (!v0.length) return xs.map(_ => 0);

  // choose C so that min(v0)+C > 0 and min(xs)+C > 0
  const minV = Math.min(...v0);
  const minX = Math.min(...xs);
  const eps = 1e-6;
  const C = Math.max( -(minV) + eps, -(minX) + eps );

  const v = v0.map(x => x + C);               // shifted samples (now > 0)
  const xsShift = xs.map(x => x + C);         // shifted grid (also > 0)

  // Log-space bandwidth on shifted data
  const y = v.map(Math.log);
  let h = kdeBandwidth(y) * factor;
  if (!Number.isFinite(h) || h <= 1e-6) {
    const ymin = Math.min(...y), ymax = Math.max(...y);
    const span = (ymax - ymin) || 1;
    h = Math.max(span * 0.05, 1e-3) * factor;
  }

  const n = y.length;
  const invnh = 1 / (n * h);
  const out = new Array(xsShift.length);

  for (let j = 0; j < xsShift.length; j++) {
    const z = Math.max(xsShift[j], eps);     // work in shifted variable z > 0
    const yl = Math.log(z);
    let s = 0;
    for (let i = 0; i < n; i++) s += gaussian((yl - y[i]) / h);
    // back-transform with Jacobian 1/z; then evaluate at x = z - C (implicit by using xsShift)
    out[j] = (s * invnh) / z;
  }
  return out;
}

const points=(xs,ys)=>xs.map((x,i)=>({x,y:ys[i]}));

// multi-dataset density chart
function makeDensityChartMulti(ctx, label, xConf){
  const {min,max,step,type='linear'}=xConf;
  return new Chart(ctx,{
    type:'line',
    data:{datasets:[]},
    options:{
      responsive:true, maintainAspectRatio:false, animation:false,
      layout:{padding:{left:10,right:10,bottom:8,top:4}},
      scales:{
        x:{ type, min, max,
            grid:{color:Chart.defaults.borderColor,tickLength:4},
            ticks:{color:Chart.defaults.color, padding:6, maxRotation:0, minRotation:0, stepSize:step, callback:(v)=>String(v)}},
        y:{min:0, max:110, grid:{color:Chart.defaults.borderColor,tickLength:4}, ticks:{display:false}}
      },
      plugins:{
        legend:{position:'bottom',labels:{boxWidth:10,boxHeight:10,usePointStyle:true,pointStyle:'line'}},
        tooltip:{mode:'index',intersect:false,callbacks:{label:(ctx)=>`${ctx.dataset.label}: ${Math.round(ctx.parsed.y)}%`}}
      },
      elements:{line:{tension:0.25,borderWidth:2}, point:{radius:0}}
    }
  });
}
function upsertDistDataset(chart, map, unitId, color){
  if(map[unitId]!=null) return map[unitId];
  const ds={label:unitId,data:[],parsing:true,borderColor:color,backgroundColor:color+'22',fill:true};
  chart.data.datasets.push(ds);
  const idx=chart.data.datasets.length-1;
  map[unitId]=idx;
  return idx;
}

// ---------- distributions state ----------
const DEG_RANGE={min:-40,max:40,step:10,gridCnt:161};
const FREQ_RANGE={min:0.01,max:5,step:1,gridCnt:200};
let distCharts={roll:null,pitch:null,freq:null, xsDeg:null, xsHz:null};
let distIdx={roll:{},pitch:{},freq:{}};

// ---------- timeseries & SOG ----------
function makeTS(){ return makeTimeseries(); }
function makeSOGChart(){ return makeSOG(); }

// ---------- unit management ----------
function ensureUnit(unitId){
  if(units[unitId]) return units[unitId];
  const baseColor=COLORS_BASE[discoveredOrder.length%COLORS_BASE.length];
  const color=themedColor(baseColor); discoveredOrder.push(unitId);
  const opt=document.createElement('option'); opt.value=unitId; opt.textContent=unitId; syncRefSelect.appendChild(opt);

  const u=units[unitId]={baseColor, color,
    visible:true,
    times:[], roll:[], pitch:[],
    seriesRoll:[], seriesPitch:[],
    seriesRollPk:[], seriesPitchPk:[],
    gnssLatLngs:[], lat0:null, lon0:null, posBuf:[],
    sogEMA:null, heading:null, sogTimes:[], sogVals:[], sogSeries:[],
    idxRoll:null, idxPitch:null, idxRollPk:null, idxPitchPk:null, idxSOG:null,
    poly:null, marker:null, nowElems:{}, statsElems:{},
    lastRollHz:NaN,lastRollAt:0,lastPitchHz:NaN,lastPitchAt:0
  };

  // timeseries datasets
  const rollDs={label:`${unitId} roll`,data:u.seriesRoll,parsing:false,borderColor:color,backgroundColor:'transparent',pointRadius:0,borderWidth:2,tension:.15,spanGaps:true};
  const pitchDs={label:`${unitId} pitch`,data:u.seriesPitch,parsing:false,borderColor:color,backgroundColor:'transparent',pointRadius:0,borderWidth:2,tension:.15,borderDash:[6,4],spanGaps:true};
  chartTS.data.datasets.push(rollDs); u.idxRoll=chartTS.data.datasets.length-1;
  chartTS.data.datasets.push(pitchDs); u.idxPitch=chartTS.data.datasets.length-1;

  // peak markers
  const rollPk={label:`${unitId} roll peaks`,type:'scatter',data:u.seriesRollPk,parsing:false,backgroundColor:color,borderColor:color,pointRadius:4,pointStyle:'circle',showLine:false};
  const pitchPk={label:`${unitId} pitch peaks`,type:'scatter',data:u.seriesPitchPk,parsing:false,backgroundColor:color,borderColor:color,pointRadius:4,pointStyle:'circle',showLine:false};
  chartTS.data.datasets.push(rollPk); u.idxRollPk=chartTS.data.datasets.length-1;
  chartTS.data.datasets.push(pitchPk); u.idxPitchPk=chartTS.data.datasets.length-1;

  // SOG dataset
  const sogDs={label:`${unitId} SOG`,data:u.sogSeries,parsing:false,borderColor:color,backgroundColor:'transparent',pointRadius:0,borderWidth:2,tension:.15,spanGaps:true};
  chartSOG.data.datasets.push(sogDs); u.idxSOG=chartSOG.data.datasets.length-1;

  // map layers
  u.poly=L.polyline([], {color,weight:3,opacity:0.95}).addTo(map);
  u.marker=L.circleMarker([0,0], {radius:6,color,fillColor:color,fillOpacity:1}).addTo(map);
  u.poly.setStyle({opacity:0}); u.marker.setStyle({opacity:0,fillOpacity:0});

  // Now card
  const nowCard=document.createElement('div'); nowCard.className='unitNow uNums'; nowCard.style.setProperty('--ucolor',color);
  nowCard.innerHTML=`<div class="unitTag" id="tag-${unitId}" style="background:${color}">${unitId}</div>
    <div class="grid">
      <div><div class="small">Roll</div><div class="num" id="now-roll-${unitId}">–</div></div>
      <div><div class="small">Pitch</div><div class="num" id="now-pitch-${unitId}">–</div></div>
      <div><div class="small">Freq (Hz)</div><div class="num" id="now-hz-${unitId}">–</div></div>
      <div><div class="small">SOG (kt)</div><div class="num" id="now-sog-${unitId}">–</div></div>
      <div><div class="small">Mean SOG (kt)</div><div class="num" id="now-sogmean-${unitId}">–</div></div>
      <div><div class="small">Heading (°)</div><div class="num" id="now-hdg-${unitId}">–</div></div>
      <div style="grid-column:1/-1"><div class="small">Lat, Lon</div><div class="small mono" id="now-ll-${unitId}">–</div></div>
    </div>`;
  nowUnits.appendChild(nowCard);
  u.nowElems={ roll:$(`now-roll-${unitId}`), pitch:$(`now-pitch-${unitId}`), hz:$(`now-hz-${unitId}`),
               sog:$(`now-sog-${unitId}`), sogMean:$(`now-sogmean-${unitId}`), hdg:$(`now-hdg-${unitId}`), ll:$(`now-ll-${unitId}`) };

  // Stats card
  const statsCol=document.createElement('div'); statsCol.className='card half unitStats'; statsCol.style.setProperty('--ucolor',color);
  statsCol.innerHTML=`<div style="font-weight:700;margin-bottom:8px;"><span class="unitTag" style="background:${color}">${unitId}</span> — window stats</div>
    <div class="grid">
      <div><div class="small">Mean Roll</div><div class="num" id="st-roll-mean-${unitId}">–</div></div>
      <div><div class="small">Std Roll</div><div class="num" id="st-roll-std-${unitId}">–</div></div>
      <div><div class="small">Mean Pitch</div><div class="num" id="st-pitch-mean-${unitId}">–</div></div>
      <div><div class="small">Std Pitch</div><div class="num" id="st-pitch-std-${unitId}">–</div></div>
      <div><div class="small">Peaks Roll</div><div class="num" id="st-roll-pk-${unitId}">0</div></div>
      <div><div class="small">Peaks Pitch</div><div class="num" id="st-pitch-pk-${unitId}">0</div></div>
      <div><div class="small">Freq Roll (Hz)</div><div class="num" id="st-roll-hz-${unitId}">–</div></div>
      <div><div class="small">Freq Pitch (Hz)</div><div class="num" id="st-pitch-hz-${unitId}">–</div></div>
      <div style="grid-column:1/-1"><div class="small">Mean SOG (kt)</div><div class="num" id="st-sog-mean-${unitId}">–</div></div>
    </div>`;
  statsUnits.appendChild(statsCol);
  u.statsElems={ rMean:$(`st-roll-mean-${unitId}`), rStd:$(`st-roll-std-${unitId}`),
                 pMean:$(`st-pitch-mean-${unitId}`), pStd:$(`st-pitch-std-${unitId}`),
                 rPk:$(`st-roll-pk-${unitId}`), pPk:$(`st-pitch-pk-${unitId}`),
                 rHz:$(`st-roll-hz-${unitId}`), pHz:$(`st-pitch-hz-${unitId}`),
                 sogMean:$(`st-sog-mean-${unitId}`) };

  // settings checkbox
  const row=document.createElement('div');
  row.innerHTML=`<label style="display:flex;gap:8px;align-items:center">
    <input type="checkbox" id="chk-${unitId}" checked/>
    <span class="unitTag" id="tag-${unitId}-settings" style="background:${color}">${unitId}</span>
    <span class="tiny">show/hide</span></label>`;
  unitsList.appendChild(row);
  row.querySelector('input').addEventListener('change',(e)=>{
    u.visible=e.target.checked;
    [u.idxRoll,u.idxPitch,u.idxRollPk,u.idxPitchPk].forEach(i=>chartTS.data.datasets[i].hidden=!u.visible);
    chartSOG.data.datasets[u.idxSOG].hidden=!u.visible;
    const rI=distIdx.roll[unitId]; if(rI!=null) distCharts.roll.data.datasets[rI].hidden=!u.visible;
    const pI=distIdx.pitch[unitId]; if(pI!=null) distCharts.pitch.data.datasets[pI].hidden=!u.visible;
    const fI=distIdx.freq[unitId];  if(fI!=null) distCharts.freq.data.datasets[fI].hidden=!u.visible;
    chartTS.update('none'); chartSOG.update('none');
    if(distCharts.roll) distCharts.roll.update('none');
    if(distCharts.pitch) distCharts.pitch.update('none');
    if(distCharts.freq) distCharts.freq.update('none');
  });

  if(getRefUnit()===unitId && globalT0===null) resetSyncSeries();
  chartTS.update('none'); chartSOG.update('none');
  return u;
}

// apply themed colors to all unit visuals
function refreshUnitStylesForTheme(mode){
  for(const id of Object.keys(units)){
    const u=units[id];
    const c = (mode==='light') ? darkenHex(u.baseColor,0.22) : u.baseColor;
    u.color = c;
    // timeseries
    chartTS.data.datasets[u.idxRoll].borderColor = c;
    chartTS.data.datasets[u.idxPitch].borderColor = c;
    chartTS.data.datasets[u.idxRollPk].backgroundColor = c;
    chartTS.data.datasets[u.idxRollPk].borderColor = c;
    chartTS.data.datasets[u.idxPitchPk].backgroundColor = c;
    chartTS.data.datasets[u.idxPitchPk].borderColor = c;
    chartSOG.data.datasets[u.idxSOG].borderColor = c;
    // map
    if(u.poly) u.poly.setStyle({color:c});
    if(u.marker) u.marker.setStyle({color:c, fillColor:c});
    // tags/cards accent
    const tagNow = document.getElementById(`tag-${id}`);
    if(tagNow) tagNow.style.background = c;
    const tagSet = document.getElementById(`tag-${id}-settings`);
    if(tagSet) tagSet.style.background = c;
    const nowCard = u.nowElems?.roll && document.querySelector(`#now-roll-${id}`)?.closest('.uNums');
    if(nowCard) nowCard.style.setProperty('--ucolor', c);
    const statEl = document.querySelector(`#st-roll-mean-${id}`)?.closest('.unitStats');
    if(statEl) statEl.style.setProperty('--ucolor', c);
    // distributions datasets if created
    const rI=distIdx.roll[id]; if(rI!=null){ const ds=distCharts.roll.data.datasets[rI]; ds.borderColor=c; ds.backgroundColor=c+'22'; }
    const pI=distIdx.pitch[id]; if(pI!=null){ const ds=distCharts.pitch.data.datasets[pI]; ds.borderColor=c; ds.backgroundColor=c+'22'; }
    const fI=distIdx.freq[id];  if(fI!=null){ const ds=distCharts.freq.data.datasets[fI]; ds.borderColor=c; ds.backgroundColor=c+'22'; }
  }
}

// ---------- helpers: windows, axes, prune ----------
const viewRange=$('viewSecRange'), viewNum=$('viewSec'); let currentViewSec=parseInt(viewNum.value||'30',10);
function applyViewWindow(val){ currentViewSec=clamp(parseInt(val||'30',10),5,600); viewRange.value=currentViewSec; viewNum.value=currentViewSec; updateAxisRange(); }
viewRange.addEventListener('input',e=>applyViewWindow(e.target.value));
viewNum.addEventListener('change',e=>applyViewWindow(e.target.value));

const winRange=$('winSecRange'), winNum=$('winSec');
function applyWindow(val){ const v=clamp(parseInt(val||'30',10),5,600); winRange.value=v; winNum.value=v; recomputePeaksAndStatsAll(); chartTS.update('none'); chartSOG.update('none'); }
winRange.addEventListener('input',e=>applyWindow(e.target.value));
winNum.addEventListener('change',e=>applyWindow(e.target.value));

function updateAxisRange(){
  if(globalT0===null){
    if(chartTS){chartTS.options.scales.x.min=0; chartTS.options.scales.x.max=currentViewSec; chartTS.update('none');}
    if(chartSOG){chartSOG.options.scales.x.min=0; chartSOG.options.scales.x.max=currentViewSec; chartSOG.update('none');}
    return;
  }
  const last=syncLastMs||Date.now();
  const nowSec=(last-globalT0)/1000;
  const xmin=Math.max(0,nowSec-currentViewSec), xmax=Math.max(currentViewSec,nowSec);
  if(chartTS){chartTS.options.scales.x.min=Number(xmin.toFixed(1)); chartTS.options.scales.x.max=Number(xmax.toFixed(1)); chartTS.update('none');}
  if(chartSOG){chartSOG.options.scales.x.min=Number(xmin.toFixed(1)); chartSOG.options.scales.x.max=Number(xmax.toFixed(1)); chartSOG.update('none');}
}
function nearestIdx(times,target){
  if(!times.length) return -1;
  let i=times.length-1;
  while(i>0 && times[i-1]>target) i--;
  const c1=i, c0=Math.max(0,i-1);
  const d1=Math.abs(times[c1]-target), d0=Math.abs(times[c0]-target);
  return (d1<=d0)?c1:c0;
}
function pruneOld(nowMs){
  const keepMs=Math.max(parseFloat(winNum.value||'30')*1000,MAX_KEEP_SEC*1000);
  for(const id of Object.keys(units)){
    const u=units[id];
    while(u.times.length && u.times[0]<nowMs-keepMs){u.times.shift();u.roll.shift();u.pitch.shift();}
    while(u.seriesRoll.length && (globalT0 + u.seriesRoll[0].x*1000) < nowMs-keepMs){u.seriesRoll.shift();u.seriesPitch.shift();}
    while(u.gnssLatLngs.length>GNSS_KEEP){u.gnssLatLngs.shift(); if(u.poly) u.poly.setLatLngs(u.gnssLatLngs);}
    while(u.posBuf.length && u.posBuf[0].t < nowMs - getSogWinSec()*1000){u.posBuf.shift();}
    while(u.sogTimes.length && u.sogTimes[0]<nowMs-keepMs){u.sogTimes.shift();u.sogVals.shift();}
    while(u.sogSeries.length && (globalT0 + u.sogSeries[0].x*1000) < nowMs-keepMs){u.sogSeries.shift();}
  }
}

// ---------- peaks & stats + distributions ----------
function detectPeaks(vals,times,minDistMs,minProm){
  const n=vals.length; if(n<3) return [];
  const peaks=[]; let lastT=-1e18;
  for(let i=1;i<n-1;i++){
    const v=vals[i]; if(v<=vals[i-1]||v<=vals[i+1]) continue;
    const w=5,i0=Math.max(0,i-w),i1=Math.min(n-1,i+w);
    let base=vals[i0]; for(let j=i0+1;j<=i1;j++) base=Math.min(base,vals[j]);
    if(v-base<minProm) continue;
    const t=times[i]; if(t-lastT<minDistMs) continue;
    peaks.push({t,v,i}); lastT=t;
  }
  return peaks;
}
function getWindowForUnit(u, winSec){
  if(!u.times.length) return {tWin:[], rWin:[], pWin:[], startMs:NaN, nowU:NaN};
  const nowU=u.times[u.times.length-1], startMs=nowU - winSec*1000;
  let s=0; while(s<u.times.length && u.times[s]<startMs) s++;
  return { tWin:u.times.slice(s), rWin:u.roll.slice(s), pWin:u.pitch.slice(s), startMs, nowU };
}
function freqSamplesFromPeaks(peaks){
  const out=[];
  for(let i=1;i<peaks.length;i++){
    const dt=(peaks[i].t-peaks[i-1].t)/1000;
    if(dt>0){ const f=1/dt; if(f>=FREQ_RANGE.min && f<=FREQ_RANGE.max) out.push(f); }
  }
  return out;
}
function updateUnifiedDistributions(){
  if(!distCharts.roll||!distCharts.pitch||!distCharts.freq) return;
  const winSec=parseFloat(winNum.value||'30');

  if(!distCharts.xsDeg){ distCharts.xsDeg=linspace(DEG_RANGE.min,DEG_RANGE.max,DEG_RANGE.gridCnt); }
  if(!distCharts.xsHz){  distCharts.xsHz =linspace(FREQ_RANGE.min,FREQ_RANGE.max,FREQ_RANGE.gridCnt); }

  for(const ds of distCharts.roll.data.datasets){ ds.hidden=true; ds.data.length=0; }
  for(const ds of distCharts.pitch.data.datasets){ ds.hidden=true; ds.data.length=0; }
  for(const ds of distCharts.freq.data.datasets){ ds.hidden=true; ds.data.length=0; }

  const angK=getKdeFactorAngles();
  const frqK=getKdeFactorFreq();

  for(const id of Object.keys(units)){
    const u=units[id];
    const rI=upsertDistDataset(distCharts.roll, distIdx.roll, id, u.color);
    const pI=upsertDistDataset(distCharts.pitch,distIdx.pitch,id, u.color);
    const fI=upsertDistDataset(distCharts.freq, distIdx.freq, id, u.color);

    if(!u.visible || !u.times.length){
      distCharts.roll.data.datasets[rI].hidden=true;
      distCharts.pitch.data.datasets[pI].hidden=true;
      distCharts.freq.data.datasets[fI].hidden=true;
      continue;
    }

    const {tWin,rWin,pWin}=getWindowForUnit(u,winSec);

    // roll density (NEG & POS via shift→log→back)
    if(rWin.length){
      let ys=kdeOnGridLogBackShift(rWin,distCharts.xsDeg,angK);
      const m=Math.max(...ys,0); ys = m>0 ? ys.map(y=>y/m*100) : ys.map(_=>0);
      const ds=distCharts.roll.data.datasets[rI];
      ds.data=points(distCharts.xsDeg,ys);
      ds.borderColor=u.color; ds.backgroundColor=u.color+'22';
      ds.hidden=false;
    }

    // pitch density (NEG & POS via shift→log→back)
    if(pWin.length){
      let ys=kdeOnGridLogBackShift(pWin,distCharts.xsDeg,angK);
      const m=Math.max(...ys,0); ys = m>0 ? ys.map(y=>y/m*100) : ys.map(_=>0);
      const ds=distCharts.pitch.data.datasets[pI];
      ds.data=points(distCharts.xsDeg,ys);
      ds.borderColor=u.color; ds.backgroundColor=u.color+'22';
      ds.hidden=false;
    }

    // frequency density (positive-only, standard log-KDE)
    const rPeaks=detectPeaks(rWin,tWin,parseFloat($('minDist').value||'300'),parseFloat($('minProm').value||'5.0'));
    const fSamples=freqSamplesFromPeaks(rPeaks);
    if(fSamples.length){
      let ys=kdeOnGridLogBack(fSamples,distCharts.xsHz,frqK);
      const m=Math.max(...ys,0); ys = m>0 ? ys.map(y=>y/m*100) : ys.map(_=>0);
      const ds=distCharts.freq.data.datasets[fI];
      ds.data=points(distCharts.xsHz,ys);
      ds.borderColor=u.color; ds.backgroundColor=u.color+'22';
      ds.hidden=false;
    }
  }

  distCharts.roll.update('none');
  distCharts.pitch.update('none');
  distCharts.freq.update('none');
}
function recomputePeaksAndStatsAll(){
  const winSec=parseFloat(winNum.value||'30'), minDist=parseFloat($('minDist').value||'300'), minProm=parseFloat($('minProm').value||'5.0');

  for(const id of Object.keys(units)){
    const u=units[id]; if(!u.times.length) continue;
    const {tWin,rWin,pWin,nowU,startMs}=getWindowForUnit(u,winSec);

    const rPeaks=detectPeaks(rWin,tWin,minDist,minProm);
    const pPeaks=detectPeaks(pWin,tWin,minDist,minProm);

    u.seriesRollPk.length=0; u.seriesPitchPk.length=0;
    for(const pk of rPeaks){u.seriesRollPk.push({x:(pk.t-globalT0)/1000,y:pk.v});}
    for(const pk of pPeaks){u.seriesPitchPk.push({x:(pk.t-globalT0)/1000,y:pk.v});}

    const freq=(peaks)=>{ if(peaks.length<2) return NaN; let s=0,c=0; for(let i=1;i<peaks.length;i++){const dt=(peaks[i].t-peaks[i-1].t)/1000; if(dt>0){s+=dt;c++;}} return c?1/(s/c):NaN; };
    const fR=freq(rPeaks), fP=freq(pPeaks);
    if(Number.isFinite(fR)){u.lastRollHz=fR;u.lastRollAt=nowU;}
    if(Number.isFinite(fP)){u.lastPitchHz=fP;u.lastPitchAt=nowU;}
    const fShowR=(Number.isFinite(u.lastRollHz)&&(nowU-(u.lastRollAt||0)<FREQ_HOLD_MS))?u.lastRollHz:(Number.isFinite(fR)?fR:NaN);
    const fShowP=(Number.isFinite(u.lastPitchHz)&&(nowU-(u.lastPitchAt||0)<FREQ_HOLD_MS))?u.lastPitchHz:(Number.isFinite(fP)?fP:NaN);

    const rs=meanStd(rWin), ps=meanStd(pWin);
    if(u.statsElems.rMean) u.statsElems.rMean.textContent=isFinite(rs.mean)?rs.mean.toFixed(2):'–';
    if(u.statsElems.rStd)  u.statsElems.rStd.textContent =isFinite(rs.std)? rs.std.toFixed(2) :'–';
    if(u.statsElems.pMean) u.statsElems.pMean.textContent=isFinite(ps.mean)?ps.mean.toFixed(2):'–';
    if(u.statsElems.pStd)  u.statsElems.pStd.textContent =isFinite(ps.std)? ps.std.toFixed(2) :'–';
    if(u.statsElems.rPk)   u.statsElems.rPk.textContent  =rPeaks.length;
    if(u.statsElems.pPk)   u.statsElems.pPk.textContent  =pPeaks.length;
    if(u.statsElems.rHz)   u.statsElems.rHz.textContent  =isFinite(fShowR)?fShowR.toFixed(2):'–';
    if(u.statsElems.pHz)   u.statsElems.pHz.textContent  =isFinite(fShowP)?fShowP.toFixed(2):'–';

    // Mean SOG (window)
    let sIdx=0; while(sIdx<u.sogTimes.length && u.sogTimes[sIdx]<startMs) sIdx++;
    const sogWin=u.sogVals.slice(sIdx);
    const sogStats=meanStd(sogWin);
    if(u.statsElems.sogMean) u.statsElems.sogMean.textContent=isFinite(sogStats.mean)?sogStats.mean.toFixed(2):'–';
    if(u.nowElems.sogMean)   u.nowElems.sogMean.textContent  =isFinite(sogStats.mean)?sogStats.mean.toFixed(2):'–';

    const fNow = Number.isFinite(fShowR)?fShowR:(Number.isFinite(fShowP)?fShowP:NaN);
    if(u.nowElems.hz) u.nowElems.hz.textContent = isFinite(fNow)? fNow.toFixed(2):'–';
  }

  updateUnifiedDistributions();
}

// ---------- sync plotting ----------
function resetSyncSeries(){
  syncLastMs=null;
  let tfirst=null;
  for(const id of Object.keys(units)){ if(units[id].times.length){ tfirst=(tfirst===null)?units[id].times[0]:Math.min(tfirst,units[id].times[0]); } }
  if(tfirst!==null) globalT0=tfirst;
  for(const id of Object.keys(units)){ units[id].seriesRoll.length=0; units[id].seriesPitch.length=0; }
  chartTS.update('none'); updateAxisRange(); log(`sync reset → ref=${getRefUnit()||'none'}`);
}
function appendSyncedPoint(t_ref){
  if(globalT0===null) globalT0=t_ref;
  const tol=parseFloat($('syncTol').value||'120');
  const x=(t_ref-globalT0)/1000;

  for(const id of Object.keys(units)){
    const u=units[id]; const idx=nearestIdx(u.times,t_ref);
    let yR=null,yP=null;
    if(idx>=0 && Math.abs(u.times[idx]-t_ref)<=tol){ yR=u.roll[idx]; yP=u.pitch[idx]; }
    else {
      const lastR=u.seriesRoll.length?u.seriesRoll[u.seriesRoll.length-1].y:null;
      const lastP=u.seriesPitch.length?u.seriesPitch[u.seriesPitch.length-1].y:null;
      const rawR=u.roll.length?u.roll[u.roll.length-1]:null;
      const rawP=u.pitch.length?u.pitch[u.pitch.length-1]:null;
      yR=(lastR!=null)?lastR:(rawR!=null?rawR:null);
      yP=(lastP!=null)?lastP:(rawP!=null?rawP:null);
      if(yR===null && yP===null) continue;
    }
    u.seriesRoll.push({x,y:yR});
    u.seriesPitch.push({x,y:yP});
  }

  syncLastMs=t_ref;
  pruneOld(t_ref);
  recomputePeaksAndStatsAll();
  updateAxisRange();
  chartTS.update('none'); chartSOG.update('none');
}

// ---------- velocity over sliding window ----------
const Rm=6371000;
function projLocalMeters(lat0,lon0,lat,lon){const toR=a=>a*Math.PI/180;return {x:(toR(lon)-toR(lon0))*Math.cos(toR(lat0))*Rm,y:(toR(lat)-toR(lat0))*Rm}}
function bearingFromV(vx,vy){ const toD=a=>a*180/Math.PI; let brg=toD(Math.atan2(vx,vy)); if(brg<0) brg+=360; return brg; }
const KNOTS_PER_MPS=1.94384449;
function updateVelocityFromWindow(u,t,lat,lon){
  if(u.lat0===null||u.lon0===null){ u.lat0=lat; u.lon0=lon; }
  const p=projLocalMeters(u.lat0,u.lon0,lat,lon);
  u.posBuf.push({t,lat,lon,x:p.x,y:p.y});
  const winMs=getSogWinSec()*1000;
  while(u.posBuf.length && u.posBuf[0].t < t - winMs){ u.posBuf.shift(); }
  if(u.posBuf.length<2) return;

  const times=u.posBuf.map(pt=>(pt.t-u.posBuf[0].t)/1000);
  const xs=u.posBuf.map(pt=>pt.x), ys=u.posBuf.map(pt=>pt.y);
  const n=times.length;
  let mt=0,mx=0,my=0; for(let i=0;i<n;i++){ mt+=times[i]; mx+=xs[i]; my+=ys[i]; }
  mt/=n; mx/=n; my/=n;
  let sTT=0,sTX=0,sTY=0;
  for(let i=0;i<n;i++){ const dt=times[i]-mt; sTT+=dt*dt; sTX+=dt*(xs[i]-mx); sTY+=dt*(ys[i]-my); }
  if(sTT<=0) return;
  const vx=sTX/sTT, vy=sTY/sTT;
  const spd_mps=Math.hypot(vx,vy), spd_kt=spd_mps*KNOTS_PER_MPS;

  const alpha=0.2;
  u.sogEMA=(u.sogEMA==null)?spd_kt:(u.sogEMA*(1-alpha)+spd_kt*alpha);
  u.heading=(u.sogEMA>2)?bearingFromV(vx,vy):null;

  const xPlot=(t-globalT0)/1000;
  u.sogTimes.push(t); u.sogVals.push(u.sogEMA); u.sogSeries.push({x:xPlot,y:u.sogEMA});
}

// ---------- Recording ----------
const btnRecord=$('btnRecord'), recInfo=$('recInfo');
btnRecord.addEventListener('click',()=>{ if(!recActive){ startRec(); } else { stopRec(); } });
function startRec(){ recActive=true; recRows=[]; recStartedAt=Date.now(); btnRecord.textContent="Stop & Save"; btnRecord.classList.add('recording','blink'); if(window._rt) clearInterval(window._rt); window._rt=setInterval(()=>{recInfo.textContent=`Recording… ${((Date.now()-recStartedAt)/1000).toFixed(1)} s`;},200); log("recording started"); }
function stopRec(){
  recActive=false; btnRecord.textContent="Start Recording"; btnRecord.classList.remove('recording','blink'); if(window._rt){clearInterval(window._rt);window._rt=null;}
  if(!recRows.length){recInfo.textContent="No samples recorded.";log("no samples to save");return;}
  const header=['unit_id','timestamp_ms','iso_time','elapsed_s','seq','roll_deg','pitch_deg','lat','lon','gnss_ms','gnss_iso'];
  const lines=[header.join(',')];
  for(const r of recRows){
    const iso=new Date(r.t).toISOString();
    lines.push([r.unit,r.t,`"${iso.replace(/"/g,'""')}"`,
                (globalT0!==null?((r.t-globalT0)/1000).toFixed(3):''),
                (r.seq??''),r.roll.toFixed(6),r.pitch.toFixed(6),
                (Number.isFinite(r.lat)?r.lat.toFixed(6):''),(Number.isFinite(r.lon)?r.lon.toFixed(6):''),
                (r.gnss_ms??''), r.gnss_iso?`"${r.gnss_iso}"`:''].join(','));
  }
  const csv=lines.join('\n'), blob=new Blob([csv],{type:'text/csv'}), d=new Date(recStartedAt||Date.now());
  const fname=`trollsports_multi_${d.getFullYear()}-${fmt2(d.getMonth()+1)}-${fmt2(d.getDate())}_${fmt2(d.getHours())}-${fmt2(d.getMinutes())}-${fmt2(d.getSeconds())}.csv`;
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=fname; document.body.appendChild(a); a.click();
  setTimeout(()=>{URL.revokeObjectURL(a.href);a.remove();},1000);
  recInfo.textContent=`Saved ${recRows.length} samples to ${fname}`; log(`saved CSV (${recRows.length} rows)`);
}

// ---------- Tabs ----------
document.querySelectorAll('.tabbtn').forEach(b=>b.addEventListener('click',()=>{
  const name=b.dataset.tab; ['plot','stats','settings'].forEach(t=>document.getElementById('tab-'+t).classList.add('hidden'));
  document.getElementById('tab-'+name).classList.remove('hidden');
  document.querySelectorAll('.tabbtn').forEach(x=>x.classList.toggle('active',x.dataset.tab===name));
  if(name==='plot'){
    try{ distCharts.roll.resize();  distCharts.roll.update('none'); }catch{}
    try{ distCharts.pitch.resize(); distCharts.pitch.update('none'); }catch{}
    try{ distCharts.freq.resize();  distCharts.freq.update('none'); }catch{}
  }
}));

// ---------- Unlock & connect ----------
document.getElementById('btnUnlock').addEventListener('click',async ()=>{
  const pwd=document.getElementById('pw').value; if(!pwd){document.getElementById('unlockMsg').textContent='Enter a password.';return;}
  if(!ENCRYPTED_CREDS||ENCRYPTED_CREDS==='PASTE_CIPHERTEXT_HERE'){ document.getElementById('unlockMsg').textContent='No encrypted creds embedded.'; return; }
  try{
    const creds=await decryptCreds(pwd,ENCRYPTED_CREDS);
    viewer.user=creds.user; viewer.pass=creds.pass; unlocked=true;
    document.getElementById('gate').classList.add('hidden'); document.getElementById('app').classList.remove('hidden');
    document.getElementById('cid').value='web-'+Math.random().toString(16).slice(2,10);

    chartTS=makeTS(); chartSOG=makeSOGChart(); makeMap();

    // init per-athlete distribution charts
    (function initDists(){
      const rctx=document.getElementById('dist-roll').getContext('2d');
      const pctx=document.getElementById('dist-pitch').getContext('2d');
      const fctx=document.getElementById('dist-freq').getContext('2d');
      distCharts.roll = makeDensityChartMulti(rctx,'Roll', {min:DEG_RANGE.min,max:DEG_RANGE.max,step:DEG_RANGE.step,type:'linear'});
      distCharts.pitch= makeDensityChartMulti(pctx,'Pitch',{min:DEG_RANGE.min,max:DEG_RANGE.max,step:DEG_RANGE.step,type:'linear'});
      distCharts.freq = makeDensityChartMulti(fctx,'Freq',  {min:FREQ_RANGE.min,max:FREQ_RANGE.max,step:FREQ_RANGE.step,type:'linear'});
      distCharts.xsDeg=null; distCharts.xsHz=null;
    })();

    setStatus('unlocked — not connected',false);
    applyWindow(document.getElementById('winSec').value); applyViewWindow(document.getElementById('viewSec').value);
    syncRefSelect.addEventListener('change', e=>setSyncRefMode(e.target.value));

    // Theme UI + initial apply
    initThemeUI();
    applyTheme(currentThemeChoice());

    if(document.getElementById('autoconn').checked) connect();
  }catch(e){ document.getElementById('unlockMsg').textContent='Wrong password or corrupted ciphertext.'; }
});

function connect(){
  if(!unlocked) return;
  if(client){ try{client.end(true);}catch(e){} client=null; }
  const host=document.getElementById('host').value.trim(), port=document.getElementById('port').value.trim(), path=document.getElementById('path').value.trim()||'/mqtt';
  const topic=document.getElementById('topic').value.trim(), cid=document.getElementById('cid').value||('web-'+Math.random().toString(16).slice(2,10));
  document.getElementById('cid').value=cid; const url=`wss://${host}:${port}${path}`; document.getElementById('url').textContent=url;

  client=mqtt.connect(url,{protocolVersion:4,clean:true,connectTimeout:8000,username:viewer.user,password:viewer.pass,clientId:cid,keepalive:30,resubscribe:true});
  client.on('connect',()=>{setStatus('connected',true);client.subscribe(topic,{qos:0});log('connected & subscribed: '+topic);});
  client.on('reconnect',()=>{setStatus('reconnecting…',false);log('reconnecting');});
  client.on('close',()=>{setStatus('disconnected',false);log('closed');});
  client.on('error',e=>{setStatus('error',false);log('error: '+(e?.message||e));});
  client.on('message',(topic,payload)=>{
    try{
      const t=Date.now();
      let txt; try{txt=new TextDecoder().decode(payload);}catch{txt=payload.toString?payload.toString():'';}
      const d=JSON.parse(txt);
      let unit=d.unit_id; if(!unit){const m=topic.split('/'); if(m.length>=3) unit=m[1];}
      if(!unit) unit='unknown';
      if(globalT0===null) globalT0=t;

      const u=ensureUnit(unit);
      let roll=d.roll_deg, pitch=d.pitch_deg;
      if((roll===undefined||pitch===undefined)&&d.ax!==undefined){
        const k=180/Math.PI; roll=Math.atan2(d.ay,d.az)*k; pitch=Math.atan2(-d.ax,Math.sqrt(d.ay*d.ay+d.az*d.az))*k;
      }
      if(typeof roll!=='number'||typeof pitch!=='number'){log('msg missing roll/pitch: '+txt);return;}

      // raw arrival buffers
      u.times.push(t); u.roll.push(roll); u.pitch.push(pitch);
      if(u.nowElems.roll) u.nowElems.roll.textContent=roll.toFixed(2);
      if(u.nowElems.pitch)u.nowElems.pitch.textContent=pitch.toFixed(2);

      // GNSS
      const lat=coerceNum(d.lat), lon=coerceNum(d.lon);
      const hasFix=validLatLon(lat,lon);
      if(hasFix){
        u.gnssLatLngs.push([lat,lon]);
        if(u.gnssLatLngs.length>GNSS_KEEP) u.gnssLatLngs.shift();
        u.poly.setLatLngs(u.gnssLatLngs);
        u.poly.setStyle({opacity:u.visible?0.95:0});
        u.marker.setLatLng([lat,lon]);
        u.marker.setStyle({opacity:u.visible?1:0,fillOpacity:u.visible?1:0});
        if(!firstMapFixDone) fitMapIfFirst(lat,lon);
        if(u.nowElems.ll) u.nowElems.ll.textContent=`${lat.toFixed(6)}, ${lon.toFixed(6)}`;

        updateVelocityFromWindow(u,t,lat,lon);
        if(u.nowElems.sog) u.nowElems.sog.textContent=(u.sogEMA!=null)?u.sogEMA.toFixed(2):'–';
        if(u.nowElems.hdg) u.nowElems.hdg.textContent=(u.heading!=null)?u.heading.toFixed(0):'–';
      } else { if(u.nowElems.ll) u.nowElems.ll.textContent='–'; }

      // record if active
      if(recActive){
        recRows.push({
          unit, t, seq:d.seq, roll, pitch,
          lat:(hasFix?lat:undefined), lon:(hasFix?lon:undefined),
          gnss_ms:(d.gnss_ms===null||d.gnss_ms===undefined)?undefined:d.gnss_ms,
          gnss_iso:(d.gnss_iso||'')
        });
      }

      // synced plot driver
      const ref=getRefUnit(); if(ref===unit){ appendSyncedPoint(t); }

      chartSOG.update('none');
      recomputePeaksAndStatsAll();
      updateAxisRange();

    }catch(e){log('parse error: '+e);}
  });
}

function disconnect(){ if(client){try{client.end(true);}catch(e){} client=null;} setStatus('disconnected',false); log('disconnected'); }
document.getElementById('btnConnect').addEventListener('click',connect);
document.getElementById('btnDisconnect').addEventListener('click',disconnect);
document.getElementById('btnClear').addEventListener('click',()=>{
  for(const id of Object.keys(units)){
    const u=units[id];
    u.times.length=0;u.roll.length=0;u.pitch.length=0;
    u.seriesRoll.length=0;u.seriesPitch.length=0;u.seriesRollPk.length=0;u.seriesPitchPk.length=0;
    u.gnssLatLngs.length=0; u.poly.setLatLngs([]); u.poly.setStyle({opacity:0}); u.marker.setStyle({opacity:0, fillOpacity:0});
    u.lat0=null; u.lon0=null; u.posBuf.length=0; u.sogEMA=null; u.heading=null;
    u.sogTimes.length=0; u.sogVals.length=0; u.sogSeries.length=0;
    [u.idxRoll,u.idxPitch,u.idxRollPk,u.idxPitchPk].forEach(i=>chartTS.data.datasets[i].hidden=false);
    chartSOG.data.datasets[u.idxSOG].hidden=false;
  }
  if(distCharts.roll){ for(const ds of distCharts.roll.data.datasets){ ds.data.length=0; ds.hidden=true; } distCharts.roll.update('none'); }
  if(distCharts.pitch){ for(const ds of distCharts.pitch.data.datasets){ ds.data.length=0; ds.hidden=true; } distCharts.pitch.update('none'); }
  if(distCharts.freq){ for(const ds of distCharts.freq.data.datasets){ ds.data.length=0; ds.hidden=true; } distCharts.freq.update('none'); }
  globalT0=null; syncLastMs=null; chartTS.update('none'); chartSOG.update('none'); log('cleared');
  firstMapFixDone=false; if(mapInited) map.setView([0,0],2);
});

// ---------- GNSS guards + geo ----------
function coerceNum(v){
  if(v===null||v===undefined) return null;
  if(typeof v==='string'){
    const s=v.trim().toLowerCase();
    if(s===''||s==='null'||s==='nan'||s==='undefined') return null;
  }
  const n=Number(v); return Number.isFinite(n)? n : null;
}
function validLatLon(lat,lon){return lat!==null&&lon!==null&&Number.isFinite(lat)&&Number.isFinite(lon)&&Math.abs(lat)<=90&&Math.abs(lon)<=180;}

// keep axes tight to window
setInterval(updateAxisRange,500);
</script>
</body>
</html>
