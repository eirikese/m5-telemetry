<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Roll & Pitch — Live (Protected, Peaks & Boxplots)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; }
    body { margin: 16px; }
    h2 { margin: 0 0 12px 0; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: stretch; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; box-shadow: 0 1px 6px rgba(0,0,0,.05); }
    .grow { flex: 1 1 560px; }
    .half { flex: 1 1 360px; min-width: 320px; }
    .muted { color: #666; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
    .btns { display:flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    button { padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    input[type="text"], input[type="number"], input[type="password"] { width: 100%; padding: 8px 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 8px; }
    label { font-size: 12px; color: #555; margin-bottom: 4px; display:block; }
    .hidden { display: none; }
    .ok { color: #067d00; }
    .bad { color: #bf0000; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .num { font-weight: 600; }
    .small { font-size: 12px; }
    .sl { display:grid; grid-template-columns: 1fr auto; gap: 8px; align-items:center; }
    .sl input[type="range"] { width: 100%; }
    /* Fixed plot heights */
    .plot-tall  { position: relative; height: 340px; width: 100%; }
    .plot-short { position: relative; height: 240px; width: 100%; }
    canvas { display: block; }
  </style>
  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/mqtt@5/dist/mqtt.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-boxplot@4.3.3/build/index.umd.min.js"></script>
</head>
<body>
  <h2>Roll &amp; Pitch — Live Web Plot</h2>

  <!-- Unlock panel -->
  <div id="gate" class="card half">
    <p><b>Protected dashboard</b>. Enter the site password to view the plot.</p>
    <div>
      <label>Site password</label>
      <input id="pw" type="password" placeholder="Enter password"/>
    </div>
    <div class="btns">
      <button id="btnUnlock">Unlock</button>
    </div>
    <p class="muted mono small" id="unlockMsg"></p>
  </div>

  <!-- App panel -->
  <div id="app" class="hidden">
    <div class="row">
      <div class="card half">
        <div class="grid">
          <div>
            <label>Host</label>
            <input id="host" value="afe7881f82fe42929e4a5370cddc7285.s1.eu.hivemq.cloud"/>
          </div>
          <div>
            <label>WS Port</label>
            <input id="port" value="8884"/>
          </div>
          <div>
            <label>Path</label>
            <input id="path" value="/mqtt"/>
          </div>
          <div>
            <label>Topic</label>
            <input id="topic" value="m5/dev001/telemetry"/>
          </div>
          <div>
            <label>Client ID (auto)</label>
            <input id="cid" readonly/>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="sl">
            <label>Window (seconds)</label>
            <span class="mono" id="winSecVal">120</span>
            <input id="winSec" type="range" min="10" max="600" step="10" value="120"/>
          </div>
          <div class="sl">
            <label>Min peak distance (ms)</label>
            <span class="mono" id="minDistVal">300</span>
            <input id="minDist" type="range" min="100" max="3000" step="50" value="300"/>
          </div>
          <div class="sl">
            <label>Min prominence (deg)</label>
            <span class="mono" id="minPromVal">1.0</span>
            <input id="minProm" type="range" min="0.2" max="10" step="0.1" value="1.0"/>
          </div>
        </div>

        <div class="btns">
          <button id="btnConnect">Connect</button>
          <button id="btnDisconnect">Disconnect</button>
          <button id="btnClear">Clear</button>
        </div>
        <div style="margin-top:10px">
          <div>Status: <span id="status" class="muted">locked</span></div>
          <div class="muted small">WSS URL: <span class="mono" id="url"></span></div>
          <div class="muted small" id="last"></div>
        </div>
      </div>

      <div class="card grow">
        <div class="plot-tall"><canvas id="chart_ts"></canvas></div>
        <div class="grid" style="margin-top:8px">
          <div class="card">
            <div><b>Roll Peaks</b></div>
            <div class="small">freq: <span class="num" id="rollHz">–</span> Hz | peaks: <span class="num" id="rollPk">0</span></div>
            <div class="small">mean: <span class="num" id="rollMean">–</span> | std: <span class="num" id="rollStd">–</span></div>
            <div class="small">latest: <span class="num" id="rollNow">–</span>°</div>
          </div>
          <div class="card">
            <div><b>Pitch Peaks</b></div>
            <div class="small">freq: <span class="num" id="pitchHz">–</span> Hz | peaks: <span class="num" id="pitchPk">0</span></div>
            <div class="small">mean: <span class="num" id="pitchMean">–</span> | std: <span class="num" id="pitchStd">–</span></div>
            <div class="small">latest: <span class="num" id="pitchNow">–</span>°</div>
          </div>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:16px">
      <div class="card grow">
        <div class="plot-short"><canvas id="chart_box"></canvas></div>
      </div>
    </div>
  </div>

<script>
// Register boxplot plugin explicitly (UMD)
if (window['chartjs-chart-boxplot']) {
  const bp = window['chartjs-chart-boxplot'];
  if (bp.BoxPlotController && bp.BoxAndWhiskers) {
    Chart.register(bp.BoxPlotController, bp.BoxAndWhiskers);
  } else if (bp.default) {
    Chart.register(bp.default);
  }
}

// ====== AES-GCM helpers (Web Crypto) ======
const b64d = (b64) => Uint8Array.from(atob(b64), c => c.charCodeAt(0));
async function deriveKey(password, salt) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 120000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false, ["encrypt","decrypt"]
  );
}
async function decryptCreds(passphrase, blobB64) {
  const raw = atob(blobB64);
  const j = JSON.parse(raw);
  const salt = b64d(j.salt), iv = b64d(j.iv), ct = b64d(j.ct);
  const key = await deriveKey(passphrase, salt);
  const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
  return JSON.parse(new TextDecoder().decode(new Uint8Array(pt)));
}

// ====== CONFIG ======
const ENCRYPTED_CREDS = "eyJzYWx0IjoiYU01amVaRG9rd0o5dmVDc1gwTjhoQT09IiwiaXYiOiJuTEdVM2NldmhSSGFVR2ZmIiwiY3QiOiIzeVZaUkxnRUNxaWxicU92QmExZlJkcVZUb1ZiM3NvZFArd2svK3FxTW9NZGRYZHV5V2gveTV3WmVxakZlZkV6L2ZpZjN6SEpqU3Z0TXd2OCJ9"; // <-- replace with blob from encrypt.html

// ====== Helpers ======
const $ = (id) => document.getElementById(id);
function setStatus(text, ok=false){ $("status").textContent=text; $("status").className=ok?"ok":"bad"; }
function meanStd(arr){
  if (!arr.length) return {mean:NaN,std:NaN};
  const m = arr.reduce((a,b)=>a+b,0)/arr.length;
  const v = arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length;
  return {mean:m, std:Math.sqrt(v)};
}
function quantiles(arr){
  if (!arr.length) return {min:NaN,q1:NaN,median:NaN,q3:NaN,max:NaN};
  const a = Array.from(arr).sort((x,y)=>x-y);
  const q = p => {
    if (a.length===1) return a[0];
    const pos = (a.length - 1) * p;
    const base = Math.floor(pos);
    const rest = pos - base;
    return (rest===0) ? a[base] : a[base] + rest*(a[base+1]-a[base]);
  };
  return {min:a[0], q1:q(0.25), median:q(0.5), q3:q(0.75), max:a[a.length-1]};
}
function detectPeaks(values, times, minDistMs, minProm){
  const n = values.length;
  if (n < 3) return [];
  const peaks = [];
  let lastPeakIdx = -1;
  for (let i=1;i<n-1;i++){
    const v = values[i];
    if (v <= values[i-1] || v <= values[i+1]) continue;
    const w = 5;
    const i0 = Math.max(0, i-w), i1 = Math.min(n-1, i+w);
    let base = values[i0];
    for (let j=i0+1;j<=i1;j++) base = Math.min(base, values[j]);
    const prom = v - base;
    if (prom < minProm) continue;
    if (lastPeakIdx >= 0) {
      const dt = times[i] - times[lastPeakIdx];
      if (dt < minDistMs) continue;
    }
    peaks.push({idx:i, t:times[i], v:v});
    lastPeakIdx = i;
  }
  return peaks;
}

// ====== State ======
let client = null;
let unlocked = false;
let viewer = { user:null, pass:null };
let chartTS = null, chartBox = null;

const MAX_POINTS = 3000; // plenty; we trim by time window
let t0 = null;           // first timestamp (ms) to make x relative
const xs = [];           // ms timestamps
const rollArr = [], pitchArr = [];
const rollPts = [], pitchPts = []; // {x: seconds since t0, y: value}
let rollPeaks = [], pitchPeaks = [];

// ====== Charts ======
function makeTimeseries(){
  const ctx = document.getElementById("chart_ts").getContext("2d");
  return new Chart(ctx, {
    type: "line",
    data: {
      datasets: [
        { label: "roll (deg)",  data: [], yAxisID: "y", parsing:false, pointRadius: 0, borderWidth: 2, tension: 0.1 },
        { label: "pitch (deg)", data: [], yAxisID: "y", parsing:false, pointRadius: 0, borderWidth: 2, tension: 0.1 },
        { label: "roll peaks",  type:"scatter", data: [], yAxisID: "y", parsing:false, pointRadius: 5, showLine: false },
        { label: "pitch peaks", type:"scatter", data: [], yAxisID: "y", parsing:false, pointRadius: 5, showLine: false }
      ]
    },
    options: {
      animation: false, responsive: true, maintainAspectRatio: false,
      scales: {
        x: { type: "linear", title:{display:true,text:"time (s)"} },
        y: { title:{display:true,text:"degrees"} }
      },
      plugins: { legend: { position: "bottom" } },
      resizeDelay: 100
    }
  });
}

function makeBoxplot(){
  const ctx = document.getElementById("chart_box").getContext("2d");
  return new Chart(ctx, {
    type: "boxplot",
    data: {
      labels: ["roll", "pitch"],
      datasets: [{
        label: "distribution (window)",
        data: [
          {min:0,q1:0,median:0,q3:0,max:0},
          {min:0,q1:0,median:0,q3:0,max:0}
        ]
      }]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { position: "bottom" } },
      scales: { y: { title:{display:true,text:"degrees"} } }
    }
  });
}

// ====== App logic ======
function trimByWindow(){
  const winSec = parseFloat($("winSec").value || "120");
  const cutoffMs = (xs.length? xs[xs.length-1] : 0) - winSec*1000;
  while (xs.length && xs[0] < cutoffMs) {
    xs.shift(); rollArr.shift(); pitchArr.shift();
    // remove first point in rollPts/pitchPts too
    if (rollPts.length) rollPts.shift();
    if (pitchPts.length) pitchPts.shift();
  }
}

function pushPoint(t_ms, r, p){
  if (t0 === null) t0 = t_ms;
  const xSec = (t_ms - t0) / 1000.0;

  xs.push(t_ms); rollArr.push(r); pitchArr.push(p);
  rollPts.push({x:xSec, y:r}); pitchPts.push({x:xSec, y:p});

  // cap absolute max for memory safety
  if (xs.length > MAX_POINTS) {
    xs.splice(0, xs.length - MAX_POINTS);
    rollArr.splice(0, rollArr.length - MAX_POINTS);
    pitchArr.splice(0, pitchArr.length - MAX_POINTS);
    rollPts.splice(0, rollPts.length - MAX_POINTS);
    pitchPts.splice(0, pitchPts.length - MAX_POINTS);
  }
}

function refreshCharts(){
  if (!chartTS || !chartBox) return;

  // Update time series datasets
  chartTS.data.datasets[0].data = rollPts.slice();
  chartTS.data.datasets[1].data = pitchPts.slice();

  // Peaks -> scatter with x = (t - t0)/1000
  const toX = (t) => (t0===null? 0 : (t - t0)/1000.0);
  chartTS.data.datasets[2].data = rollPeaks.map(pk => ({x: toX(pk.t), y: pk.v}));
  chartTS.data.datasets[3].data = pitchPeaks.map(pk => ({x: toX(pk.t), y: pk.v}));
  chartTS.update("none");

  // Boxplots from current window arrays
  const rb = quantiles(rollArr);
  const pb = quantiles(pitchArr);
  chartBox.data.datasets[0].data = [rb, pb];
  chartBox.update("none");

  // Numbers panel
  const rStats = meanStd(rollArr);
  const pStats = meanStd(pitchArr);
  $("rollMean").textContent  = isFinite(rStats.mean)? rStats.mean.toFixed(2) : "–";
  $("rollStd").textContent   = isFinite(rStats.std)?  rStats.std.toFixed(2)  : "–";
  $("pitchMean").textContent = isFinite(pStats.mean)? pStats.mean.toFixed(2) : "–";
  $("pitchStd").textContent  = isFinite(pStats.std)?  pStats.std.toFixed(2)  : "–";
  const lastR = rollArr[rollArr.length-1], lastP = pitchArr[pitchArr.length-1];
  $("rollNow").textContent   = (lastR!==undefined)? lastR.toFixed(2) : "–";
  $("pitchNow").textContent  = (lastP!==undefined)? lastP.toFixed(2) : "–";
  $("rollPk").textContent    = rollPeaks.length;
  $("pitchPk").textContent   = pitchPeaks.length;

  function freqFromPeaks(peaks){
    if (peaks.length < 2) return NaN;
    let sum=0, cnt=0;
    for (let i=1;i<peaks.length;i++){
      const dt = (peaks[i].t - peaks[i-1].t)/1000;
      if (dt>0) { sum += dt; cnt++; }
    }
    return cnt? 1/(sum/cnt) : NaN;
  }
  const fR = freqFromPeaks(rollPeaks);
  const fP = freqFromPeaks(pitchPeaks);
  $("rollHz").textContent  = isFinite(fR)? fR.toFixed(2) : "–";
  $("pitchHz").textContent = isFinite(fP)? fP.toFixed(2) : "–";
}

function recomputePeaks(){
  const winSec = parseFloat($("winSec").value || "120");
  const minDist = parseFloat($("minDist").value || "300");
  const minProm = parseFloat($("minProm").value || "1.0");

  // Consider only data within the window
  const startT = xs.length ? (xs[xs.length-1] - winSec*1000) : 0;
  let s = 0; while (s < xs.length && xs[s] < startT) s++;
  const valuesR = rollArr.slice(s), valuesP = pitchArr.slice(s);
  const times   = xs.slice(s);

  rollPeaks  = detectPeaks(valuesR, times, minDist, minProm);
  pitchPeaks = detectPeaks(valuesP, times, minDist, minProm);

  // Offset indices back to global arrays (we use times anyway)
  if (s>0) {
    rollPeaks.forEach(pk => pk.idx += s);
    pitchPeaks.forEach(pk => pk.idx += s);
  }
}

async function unlock(){
  const pwd = $("pw").value;
  if (!pwd) { $("unlockMsg").textContent = "Enter a password."; return; }
  if (!ENCRYPTED_CREDS || ENCRYPTED_CREDS === "PASTE_CIPHERTEXT_HERE") {
    $("unlockMsg").textContent = "No encrypted creds embedded. Generate with encrypt.html and paste the blob.";
    return;
  }
  try {
    const creds = await decryptCreds(pwd, ENCRYPTED_CREDS);
    viewer.user = creds.user; viewer.pass = creds.pass;
    unlocked = true;
    $("gate").classList.add("hidden");
    $("app").classList.remove("hidden");
    $("cid").value = "web-" + Math.random().toString(16).slice(2, 10);
    chartTS = makeTimeseries();
    chartBox = makeBoxplot();
    setStatus("unlocked — not connected");
    bindSliders(); // initialize slider labels
  } catch (e) {
    $("unlockMsg").textContent = "Wrong password or corrupted ciphertext.";
  }
}

function connect(){
  if (!unlocked) return;
  if (client) { try { client.end(true); } catch(e){} client = null; }
  const host = $("host").value.trim();
  const port = $("port").value.trim();
  const path = $("path").value.trim() || "/mqtt";
  const topic = $("topic").value.trim();
  const cid = $("cid").value || ("web-" + Math.random().toString(16).slice(2, 10));
  $("cid").value = cid;
  const url = `wss://${host}:${port}${path}`;
  $("url").textContent = url;

  client = mqtt.connect(url, {
    protocolVersion: 4, clean: true, connectTimeout: 8000,
    username: viewer.user, password: viewer.pass,
    clientId: cid, keepalive: 30, resubscribe: true
  });
  client.on("connect", () => { setStatus("connected", true); client.subscribe(topic, { qos: 0 }); });
  client.on("reconnect", () => setStatus("reconnecting…", false));
  client.on("close", () => setStatus("disconnected", false));
  client.on("error", (e) => { console.error(e); setStatus("error", false); });
  client.on("message", (topic, payload) => {
    try{
      const d = JSON.parse(new TextDecoder().decode(payload));
      let roll = d.roll_deg, pitch = d.pitch_deg;
      if ((roll === undefined || pitch === undefined) && d.ax !== undefined) {
        const k = 180 / Math.PI;
        roll  = Math.atan2(d.ay, d.az) * k;
        pitch = Math.atan2(-d.ax, Math.sqrt(d.ay*d.ay + d.az*d.az)) * k;
      }
      if (typeof roll === "number" && typeof pitch === "number") {
        const t = (typeof d.ts_ms === "number") ? d.ts_ms : (Date.now());
        pushPoint(t, roll, pitch);
        trimByWindow();
        $("last").textContent = `seq=${d.seq ?? "?"}  roll=${roll.toFixed(2)}°  pitch=${pitch.toFixed(2)}°`;
        recomputePeaks();
        refreshCharts();
      }
    } catch(e){ console.warn("parse error", e); }
  });
}

function disconnect(){
  if (client) { try { client.end(true); } catch(e){} client = null; }
  setStatus("disconnected");
}

// Slider bindings
function bindSliders(){
  const sWin = $("winSec"), sMinD = $("minDist"), sMinP = $("minProm");
  const vWin = $("winSecVal"), vMinD = $("minDistVal"), vMinP = $("minPromVal");
  const upd = () => { vWin.textContent=sWin.value; vMinD.textContent=sMinD.value; vMinP.textContent=sMinP.value; recomputePeaks(); refreshCharts(); };
  sWin.addEventListener("input", upd);
  sMinD.addEventListener("input", upd);
  sMinP.addEventListener("input", upd);
  upd();
}

document.getElementById("btnUnlock").addEventListener("click", unlock);
document.getElementById("btnConnect").addEventListener("click", connect);
document.getElementById("btnDisconnect").addEventListener("click", disconnect);
document.getElementById("btnClear").addEventListener("click", () => {
  t0 = null;
  xs.length=0; rollArr.length=0; pitchArr.length=0;
  rollPts.length=0; pitchPts.length=0;
  rollPeaks.length=0; pitchPeaks.length=0;
  refreshCharts();
});
</script>
</body>
</html>
