<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Roll & Pitch — Live (Protected, Peaks)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; }
    body { margin: 16px; }
    h2 { margin: 0 0 12px 0; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: stretch; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; box-shadow: 0 1px 6px rgba(0,0,0,.05); }
    .grow { flex: 1 1 560px; }
    .half { flex: 1 1 320px; min-width: 300px; }
    .muted { color: #666; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; }
    .btns { display:flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    button { padding: 8px 10px; border-radius: 8px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    input { width: 100%; padding: 8px 10px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 8px; }
    label { font-size: 12px; color: #555; margin-bottom: 4px; display:block; }
    .hidden { display: none; }
    .ok { color: #067d00; }
    .bad { color: #bf0000; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .num { font-weight: 600; }
    .small { font-size: 12px; }
    .log { font-size: 12px; background:#0b1020; color:#b7c3ff; padding:10px; border-radius:8px; max-height:200px; overflow:auto; }
    .plot-tall  { position: relative; height: 360px; width: 100%; }
    canvas { display: block; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/mqtt/dist/mqtt.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3"></script>
</head>
<body>
  <h2>Roll &amp; Pitch — Live Web Plot</h2>

  <!-- Unlock panel -->
  <div id="gate" class="card half">
    <p><b>Protected dashboard</b>. Enter the site password to view the plot.</p>
    <div>
      <label>Site password</label>
      <input id="pw" type="password" placeholder="Enter password"/>
    </div>
    <div class="btns">
      <button id="btnUnlock">Unlock</button>
    </div>
    <p class="muted mono small" id="unlockMsg"></p>
  </div>

  <!-- App panel -->
  <div id="app" class="hidden">
    <div class="row">
      <div class="card half">
        <div class="grid">
          <div>
            <label>Host</label>
            <input id="host" value="afe7881f82fe42929e4a5370cddc7285.s1.eu.hivemq.cloud"/>
          </div>
          <div>
            <label>WS Port</label>
            <input id="port" value="8884"/>
          </div>
          <div>
            <label>Path</label>
            <input id="path" value="/mqtt"/>
          </div>
          <div>
            <label>Topic</label>
            <input id="topic" value="m5/dev001/telemetry"/>
          </div>
          <div>
            <label>Client ID (auto)</label>
            <input id="cid" readonly/>
          </div>
          <div>
            <label>Window (seconds)</label>
            <input id="winSec" value="60"/>
          </div>
          <div>
            <label>Min peak distance (ms)</label>
            <input id="minDist" value="300"/>
          </div>
          <div>
            <label>Min prominence (deg)</label>
            <input id="minProm" value="1.0"/>
          </div>
        </div>
        <div class="btns">
          <button id="btnConnect">Connect</button>
          <button id="btnDisconnect">Disconnect</button>
          <button id="btnClear">Clear</button>
        </div>
        <div style="margin-top:10px">
          <div>Status: <span id="status" class="muted">locked</span></div>
          <div class="muted small">WSS URL: <span class="mono" id="url"></span></div>
          <div class="muted small" id="last"></div>
        </div>
      </div>

      <div class="card grow">
        <div class="plot-tall"><canvas id="chart_ts"></canvas></div>
        <div class="grid" style="margin-top:8px">
          <div class="card">
            <div><b>Roll</b></div>
            <div class="small">freq: <span class="num" id="rollHz">–</span> Hz | peaks: <span class="num" id="rollPk">0</span></div>
            <div class="small">mean: <span class="num" id="rollMean">–</span> | std: <span class="num" id="rollStd">–</span></div>
            <div class="small">latest: <span class="num" id="rollNow">–</span>°</div>
          </div>
          <div class="card">
            <div><b>Pitch</b></div>
            <div class="small">freq: <span class="num" id="pitchHz">–</span> Hz | peaks: <span class="num" id="pitchPk">0</span></div>
            <div class="small">mean: <span class="num" id="pitchMean">–</span> | std: <span class="num" id="pitchStd">–</span></div>
            <div class="small">latest: <span class="num" id="pitchNow">–</span>°</div>
          </div>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:16px">
      <div class="card grow">
        <div><b>Debug log</b></div>
        <pre class="log" id="log"></pre>
      </div>
    </div>
  </div>

<script>
// ====== AES-GCM helpers (Web Crypto) ======
const b64d = (b64) => Uint8Array.from(atob(b64), c => c.charCodeAt(0));
async function deriveKey(password, salt) {
  const enc = new TextEncoder();
  const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 120000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false, ["encrypt","decrypt"]
  );
}
async function decryptCreds(passphrase, blobB64) {
  const raw = atob(blobB64);
  const j = JSON.parse(raw);
  const salt = b64d(j.salt), iv = b64d(j.iv), ct = b64d(j.ct);
  const key = await deriveKey(passphrase, salt);
  const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
  return JSON.parse(new TextDecoder().decode(new Uint8Array(pt)));
}

// ====== CONFIG ======
const ENCRYPTED_CREDS = "eyJzYWx0IjoiYU01amVaRG9rd0o5dmVDc1gwTjhoQT09IiwiaXYiOiJuTEdVM2NldmhSSGFVR2ZmIiwiY3QiOiIzeVZaUkxnRUNxaWxicU92QmExZlJkcVZUb1ZiM3NvZFArd2svK3FxTW9NZGRYZHV5V2gveTV3WmVxakZlZkV6L2ZpZjN6SEpqU3Z0TXd2OCJ9"; // <-- replace with blob from encrypt.html

// ====== Helpers ======
const $ = (id) => document.getElementById(id);
function log(s){ const el=$("log"); el.textContent += s + "\\n"; el.scrollTop = el.scrollHeight; }
function setStatus(text, ok=false){ $("status").textContent=text; $("status").className=ok?"ok":"bad"; }
function meanStd(arr){
  if (!arr.length) return {mean:NaN,std:NaN};
  const m = arr.reduce((a,b)=>a+b,0)/arr.length;
  const v = arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length;
  return {mean:m, std:Math.sqrt(v)};
}
function detectPeaks(values, times, minDistMs, minProm){
  const n = values.length;
  if (n < 3) return [];
  const peaks = [];
  let lastT = -1e18;
  for (let i=1;i<n-1;i++){
    const v = values[i];
    if (v <= values[i-1] || v <= values[i+1]) continue;
    // simple local baseline (window = 5 samples)
    const w = 5;
    const i0 = Math.max(0, i-w), i1 = Math.min(n-1, i+w);
    let base = values[i0];
    for (let j=i0+1;j<=i1;j++) base = Math.min(base, values[j]);
    const prom = v - base;
    if (prom < minProm) continue;
    const t = times[i];
    if (t - lastT < minDistMs) continue;
    peaks.push({t, v, i});
    lastT = t;
  }
  return peaks;
}

// ====== State ======
let client = null;
let unlocked = false;
let viewer = { user:null, pass:null };
let chartTS = null;

const timesMs = []; // raw timestamps (ms)
const rollVals = [];
const pitchVals = [];
let t0 = null;

const rollSeries = [];  // [{x:sec, y:value}, ...] for chart
const pitchSeries = [];
let rollPeakPts = [];   // [{x:sec, y:value}, ...] for chart
let pitchPeakPts = [];

const MAX_KEEP_SEC = 600; // keep up to 10 min in memory

// ====== Charts ======
function makeTimeseries(){
  const ctx = document.getElementById("chart_ts").getContext("2d");
  return new Chart(ctx, {
    type: "line",
    data: {
      datasets: [
        { label: "roll (deg)",  data: rollSeries,  parsing:false,
          borderColor:"#1f77b4", backgroundColor:"rgba(31,119,180,0.1)",
          pointRadius:0, borderWidth:2, tension:0.15 },
        { label: "pitch (deg)", data: pitchSeries, parsing:false,
          borderColor:"#ff7f0e", backgroundColor:"rgba(255,127,14,0.1)",
          pointRadius:0, borderWidth:2, tension:0.15 },
        { label: "roll peaks",  type:"scatter", data: rollPeakPts, parsing:false,
          borderColor:"#2ca02c", backgroundColor:"#2ca02c", pointRadius:4, showLine:false },
        { label: "pitch peaks", type:"scatter", data: pitchPeakPts, parsing:false,
          borderColor:"#d62728", backgroundColor:"#d62728", pointRadius:4, showLine:false }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { type:"linear", title:{display:true,text:"time (s from start)"} },
        y: { title:{display:true,text:"degrees"} }
      },
      plugins: { legend: { position: "bottom" } }
    }
  });
}

// ====== App logic ======
function pruneOld(nowMs){
  const keepMs = Math.max(parseFloat($("winSec").value||"60")*1000, MAX_KEEP_SEC*1000);
  // Drop anything older than now - keepMs
  while (timesMs.length && timesMs[0] < nowMs - keepMs) {
    timesMs.shift(); rollVals.shift(); pitchVals.shift();
    rollSeries.shift(); pitchSeries.shift();
    // peak points will be rebuilt after detection
  }
}

function recomputePeaksAndStats(nowMs){
  const winSec = parseFloat($("winSec").value||"60");
  const minDist = parseFloat($("minDist").value||"300");
  const minProm = parseFloat($("minProm").value||"1.0");
  const startMs = nowMs - winSec*1000;

  // Slice window
  let s = 0; while (s < timesMs.length && timesMs[s] < startMs) s++;
  const tWin = timesMs.slice(s);
  const rWin = rollVals.slice(s);
  const pWin = pitchVals.slice(s);

  // Peaks
  const rPeaks = detectPeaks(rWin, tWin, minDist, minProm);
  const pPeaks = detectPeaks(pWin, tWin, minDist, minProm);

  rollPeakPts.length = 0;
  pitchPeakPts.length = 0;
  for (const pk of rPeaks) rollPeakPts.push({x:(pk.t - t0)/1000, y:pk.v});
  for (const pk of pPeaks) pitchPeakPts.push({x:(pk.t - t0)/1000, y:pk.v});

  // Frequency
  function freq(peaks){
    if (peaks.length < 2) return NaN;
    let sum=0, c=0;
    for (let i=1;i<peaks.length;i++){ const dt=(peaks[i].t - peaks[i-1].t)/1000; if (dt>0){sum+=dt; c++;} }
    return c? 1/(sum/c) : NaN;
  }
  const fR = freq(rPeaks);
  const fP = freq(pPeaks);
  $("rollHz").textContent  = isFinite(fR)? fR.toFixed(2) : "–";
  $("pitchHz").textContent = isFinite(fP)? fP.toFixed(2) : "–";
  $("rollPk").textContent  = rPeaks.length;
  $("pitchPk").textContent = pPeaks.length;

  // Stats
  function meanStd(arr){
    if (!arr.length) return {m:NaN,s:NaN};
    const m = arr.reduce((a,b)=>a+b,0)/arr.length;
    const v = arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length;
    return {m,s:Math.sqrt(v)};
  }
  const rs = meanStd(rWin);
  const ps = meanStd(pWin);
  $("rollMean").textContent  = isFinite(rs.m)? rs.m.toFixed(2) : "–";
  $("rollStd").textContent   = isFinite(rs.s)? rs.s.toFixed(2)  : "–";
  $("pitchMean").textContent = isFinite(ps.m)? ps.m.toFixed(2) : "–";
  $("pitchStd").textContent  = isFinite(ps.s)? ps.s.toFixed(2)  : "–";

  const lastR = rollVals[rollVals.length-1];
  const lastP = pitchVals[pitchVals.length-1];
  $("rollNow").textContent = (lastR!==undefined)? lastR.toFixed(2) : "–";
  $("pitchNow").textContent= (lastP!==undefined)? lastP.toFixed(2) : "–";
}

async function unlock(){
  const pwd = $("pw").value;
  if (!pwd) { $("unlockMsg").textContent = "Enter a password."; return; }
  if (!ENCRYPTED_CREDS || ENCRYPTED_CREDS === "PASTE_CIPHERTEXT_HERE") {
    $("unlockMsg").textContent = "No encrypted creds embedded. Generate with encrypt.html and paste the blob.";
    return;
  }
  try {
    const creds = await decryptCreds(pwd, ENCRYPTED_CREDS);
    viewer.user = creds.user; viewer.pass = creds.pass;
    unlocked = true;
    $("gate").classList.add("hidden");
    $("app").classList.remove("hidden");
    $("cid").value = "web-" + Math.random().toString(16).slice(2, 10);
    chartTS = makeTimeseries();
    setStatus("unlocked — not connected");
    log("unlocked OK");
  } catch (e) {
    $("unlockMsg").textContent = "Wrong password or corrupted ciphertext.";
  }
}

function connect(){
  if (!unlocked) return;
  if (client) { try { client.end(true); } catch(e){} client = null; }
  const host = $("host").value.trim();
  const port = $("port").value.trim();
  const path = $("path").value.trim() || "/mqtt";
  const topic = $("topic").value.trim();
  const cid = $("cid").value || ("web-" + Math.random().toString(16).slice(2, 10));
  $("cid").value = cid;
  const url = `wss://${host}:${port}${path}`;
  $("url").textContent = url;

  client = mqtt.connect(url, {
    protocolVersion: 4, clean: true, connectTimeout: 8000,
    username: viewer.user, password: viewer.pass,
    clientId: cid, keepalive: 30, resubscribe: true
  });
  client.on("connect", () => { setStatus("connected", true); client.subscribe(topic, { qos: 0 }); log("connected & subscribed: "+topic); });
  client.on("reconnect", () => { setStatus("reconnecting…", false); log("reconnecting..."); });
  client.on("close", () => { setStatus("disconnected", false); log("closed"); });
  client.on("error", (e) => { setStatus("error", false); log("error: "+(e?.message||e)); });
  client.on("message", (topic, payload) => {
    try{
      let txt;
      try { txt = new TextDecoder().decode(payload); }
      catch { txt = payload.toString ? payload.toString() : ""; }
      const d = JSON.parse(txt);
      let roll = d.roll_deg, pitch = d.pitch_deg;
      if ((roll === undefined || pitch === undefined) && d.ax !== undefined) {
        const k = 180 / Math.PI;
        roll  = Math.atan2(d.ay, d.az) * k;
        pitch = Math.atan2(-d.ax, Math.sqrt(d.ay*d.ay + d.az*d.az)) * k;
      }
      if (typeof roll !== "number" || typeof pitch !== "number") {
        log("msg missing roll/pitch: "+txt); return;
      }
      const t = (typeof d.ts_ms === "number") ? d.ts_ms : Date.now();
      if (t0 === null) t0 = t;

      // store
      timesMs.push(t);
      rollVals.push(roll);
      pitchVals.push(pitch);
      rollSeries.push({x:(t - t0)/1000, y: roll});
      pitchSeries.push({x:(t - t0)/1000, y: pitch});

      pruneOld(t);
      recomputePeaksAndStats(t);
      chartTS.update("none");

      $("last").textContent = `seq=${d.seq ?? "?"}  roll=${roll.toFixed(2)}°  pitch=${pitch.toFixed(2)}°`;
    } catch(e){ log("parse error: "+e); }
  });
}

function disconnect(){
  if (client) { try { client.end(true); } catch(e){} client = null; }
  setStatus("disconnected");
  log("disconnected");
}

document.getElementById("btnUnlock").addEventListener("click", unlock);
document.getElementById("btnConnect").addEventListener("click", connect);
document.getElementById("btnDisconnect").addEventListener("click", disconnect);
document.getElementById("btnClear").addEventListener("click", () => {
  timesMs.length=0; rollVals.length=0; pitchVals.length=0;
  rollSeries.length=0; pitchSeries.length=0;
  rollPeakPts.length=0; pitchPeakPts.length=0;
  t0 = null; chartTS.update("none"); log("cleared");
});
</script>
</body>
</html>
