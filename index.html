<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>TrollSports Live v1.5.9</title>
<meta name="theme-color" content="#ffffff"/>
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
<style>
  /* Spacing system */
  :root{
    --gap: clamp(10px, 1.8vw, 14px);
    --pad: clamp(10px, 1.8vw, 14px);
    --card-pad: clamp(12px, 2vw, 16px);

    /* theme tokens */
    --bg:#f7f9fc;
    --card:#ffffff; 
    --muted:#4e5d79; 
    --text:#0b1220; 
    --accent:#1e66f5; 
    --border:#d6deeb;
    --rec:#ff4d4d;
    --theme-color:#ffffff;
    --topbar1:#ffffff;
    --topbar2:#f6f7fb;
    --btn:#f2f6ff;
    --btn-active:#e6effe;
    --input:#f8fbff;
    --chart-text:#000000;
    --chart-grid:#e0e0e0;
    --leaflet-bg:#e6eefc;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,sans-serif;padding-bottom:env(safe-area-inset-bottom)}
  .topbar{position:sticky;top:0;z-index:10;display:flex;align-items:center;gap:10px;padding:calc(8px + env(safe-area-inset-top)) var(--pad) 8px;background:linear-gradient(180deg,var(--topbar1),var(--topbar2));border-bottom:1px solid var(--border)}
  .app-title{font-weight:700}.spacer{flex:1}.ver{color:var(--muted);font-size:12px}
  .tabs{display:flex;gap:6px}.tabbtn{padding:8px 12px;border-radius:10px;border:1px solid var(--border);background:var(--btn);color:var(--text);cursor:pointer;font-weight:600}
  .tabbtn.active{background:var(--btn-active);border-color:var(--border)}

  .wrap{padding: var(--pad); display:flex; flex-direction:column; gap: var(--gap)}
  .row{display:flex; gap: var(--gap); flex-wrap:wrap; align-items:stretch; margin-bottom: var(--gap);}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:var(--card-pad);box-shadow:0 1px 10px rgba(0,0,0,.2)}
  .grow{flex:1 1 560px}.half{flex:1 1 320px;min-width:300px}

  .small{font-size:12px;color:var(--muted)} .tiny{font-size:11px;color:var(--muted)} .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .num{font-weight:700;font-size:clamp(22px,5.8vw,34px);line-height:1.15}
  .btns{display:flex;flex-wrap:wrap;gap: calc(var(--gap) - 2px); margin-top: var(--gap)} 
  button{padding:10px 14px;border-radius:10px;border:1px solid var(--border);background:var(--btn);color:var(--text);cursor:pointer}
  input,select{width:auto;min-width:0;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:var(--input);color:var(--text);max-width:100%;overflow-wrap:break-word;}
  input[type="number"],input[type="checkbox"]{width:auto;min-width:0;}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px;max-width:100%;overflow-wrap:break-word;}
  .grid{display:grid;grid-template-columns:repeat(auto-fit, minmax(450px, 1fr));gap: var(--gap);} .hidden{display:none}.ok{color:#16c26e}.bad{color:#ff6b6b}
  /* Responsive grid for report tiles */
  .reports-tiles-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: 24px;
    margin-top: 32px;
  }
  .log{font-size:12px;background:var(--input);color:var(--text);padding:10px;border-radius:10px;max-height:200px;overflow:auto;border:1px dashed var(--border)}
  .plot{display:flex;align-items:stretch;justify-content:stretch;position:relative;height:45vh;min-height:280px;max-height:480px;width:100%}
  .plot canvas{flex:1 1 auto;width:100%!important;height:100%!important;display:block;max-height:100%;}
  .recording{background:#4a1111;border-color:#ff7a7a;color:#fff}.recording::before{content:"● ";color:var(--rec)}
  @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(255,77,77,.85)}70%{box-shadow:0 0 0 12px rgba(255,77,77,0)}100%{box-shadow:0 0 0 0 rgba(255,77,77,0)}}
  .blink{animation:pulse 1s infinite}
  .range-row{display:grid;grid-template-columns:1fr auto;gap: var(--gap);align-items:center} input[type="range"]{width:100%;accent-color:var(--accent)}
  .unitNow{border-radius:10px;padding:10px;border:1px solid var(--border);background:var(--input)}
  .unitTag{display:inline-block;padding:2px 8px;border-radius:999px;font-weight:700;margin-bottom:6px;color:#000}
  .uNums .num{color:var(--ucolor)}
  #map{height:45vh;max-height:590px;min-height:220px;border-radius:12px;overflow:hidden;display:flex;width:100%}
  .leaflet-container{flex:1 1 auto;width:100%!important;height:100%!important;background:var(--leaflet-bg)}
  .leaflet-container{background:var(--leaflet-bg)}

  /* Densities */
  .dgrid{display:grid;grid-template-columns:1fr;gap: var(--gap);margin-top: var(--gap)}
  .dens-wrap{position:relative;height:200px;border:1px solid var(--border);border-radius:8px;padding:6px 6px 4px 6px;background:var(--input);overflow:hidden}
  .dens-head{font-size:11px;color:var(--muted);margin:2px 0 4px 2px}
  .dens-wrap canvas{position:absolute;left:0;right:0;bottom:6px;top:22px;width:100% !important;height:auto !important}

  /* --- Layout for full-width Now section + padding --- */
  .nowRow { margin-bottom: var(--gap); }
  #nowUnits {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap: 12px;
    padding-bottom: calc(var(--gap) + 6px);
  }
  


  /* Make map in Map tab large */
  #tab-map #map {
    height: 70vh !important;
    max-height: 1000px !important;
    min-height: 320px !important;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/mqtt/dist/mqtt.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
<script>
  // Register and enable the annotation plugin globally
  Chart.register(window['chartjs-plugin-annotation']);
</script>
</head>
<body>
  <div class="topbar">
    <div class="app-title">TrollSports Live</div><div class="spacer"></div>
    <div class="ver">v1.5.9</div>
    <div class="tabs hidden" id="maintabs">
      <button class="tabbtn active" data-tab="plot">Plot</button>
      <button class="tabbtn" data-tab="map">Map</button>
      <button class="tabbtn" data-tab="reports">Reports</button>
      <button class="tabbtn" data-tab="settings">Settings</button>
    </div>
    <button id="btnRecord" class="hidden" style="margin-left:16px;">Start Recording</button>
  </div>

  <!-- Gate -->
  <div id="gate" class="wrap">
    <div class="card half">
      <div style="font-weight:700;margin-bottom:8px;">Protected dashboard</div>
      <div class="small">Enter site password to unlock. Viewer creds are decrypted in-browser (read-only).</div>
      <label>Site password</label><input id="pw" type="password" placeholder="Enter password"/>
      <div class="btns"><button id="btnUnlock">Unlock</button></div>
      <div id="unlockMsg" class="small"></div>
    </div>
  </div>

  <!-- App -->
  <div id="app" class="wrap hidden">
    <!-- PLOT TAB -->
    <section id="tab-plot">
      <div class="row">
        <div class="card half" id="nowPanel">
          <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px;">
            <span style="font-weight:700;">Now</span>
            <div style="display:flex;gap:8px;">
              <button id="btnToggleLivePlot" class="small">Pause Live Plotting</button>
              <button id="btnStayAwake" class="small">Stay Awake</button>
            </div>
          </div>
          <div id="nowUnits" class="grid" style="margin-top:10px;grid-template-columns:repeat(auto-fit, minmax(240px, 1fr));gap:12px"></div>
        </div>
      </div>
      <div class="row">
        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">IMU Timeseries</div>
          <div class="plot" style="height:40vh;min-height:260px;"><canvas id="chart_ts"></canvas></div>
        </div>
        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">SOG Timeseries</div>
          <div class="plot" style="height:40vh;min-height:260px;"><canvas id="chart_sog"></canvas></div>
          <div class="small" id="sogInfo"></div>
        </div>
      </div>

      <div class="row">
        <div class="card half">
          <div class="dens-head" style="font-weight:700;">Roll (°) — per athlete</div>
          <div class="plot"><canvas id="dist-roll"></canvas></div>
        </div>
        <div class="card half">
          <div class="dens-head" style="font-weight:700;">Pitch (°) — per athlete</div>
          <div class="plot"><canvas id="dist-pitch"></canvas></div>
        </div>
      </div>
      <div class="row">
        <div class="card half">
          <div class="dens-head" style="font-weight:700;">Frequency (Roll, Hz) — per athlete</div>
          <div class="plot"><canvas id="dist-freq-roll"></canvas></div>
        </div>
        <div class="card half">
          <div class="dens-head" style="font-weight:700;">Frequency (Pitch, Hz) — per athlete</div>
          <div class="plot"><canvas id="dist-freq-pitch"></canvas></div>
        </div>
      </div>
      <div class="tiny">Roll/Pitch X: −40…+40°. Frequency X: 0.01–5 Hz. Y: direct percentage (density × 100).</div>
    </section>

    <!-- MAP TAB -->
    <section id="tab-map" class="hidden">
      <div class="row">
        <div class="card grow">
          <div style="font-weight:700;margin-bottom:8px;">GNSS Map</div>
          <div class="btns" style="margin-bottom:8px;">
            <button id="btnTopMark">Add Top Mark</button>
            <button id="btnStartLine">Add Start Line</button>
          </div>
          <div id="map"></div>
          <div class="small" id="mapCredit">Basemap © OpenStreetMap, © CARTO — Dark Matter</div>
        </div>
      </div>
    </section>


    <!-- REPORTS TAB -->
    <section id="tab-reports" class="hidden">
      <div class="row">
        <div class="card grow">
          <div style="font-weight:700;margin-bottom:8px;">Reports</div>
          <div id="reportsTabs" class="tabs" style="margin-bottom:12px;"></div>
          <div id="reportsContent"></div>
        </div>
      </div>
    </section>

    <!-- SETTINGS TAB -->
    <section id="tab-settings" class="hidden">
      <div class="row">
        <!-- Connection -->
        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Connection</div>
          <div class="grid">
            <div><label>Host</label><input id="host" value="afe7881f82fe42929e4a5370cddc7285.s1.eu.hivemq.cloud"/></div>
            <div><label>WS Port</label><input id="port" value="8884"/></div>
            <div><label>Path</label><input id="path" value="/mqtt"/></div>
            <div><label>Topic</label><input id="topic" value="m5/+/telemetry"/></div>
            <div><label>Client ID (auto)</label><input id="cid" readonly/></div>
            <div><label>Auto-connect after unlock</label><input id="autoconn" type="checkbox" checked/></div>
          </div>
          <div class="small">
            Status: <span id="status" class="bad">disconnected</span><br/>
            WSS: <span id="url" class="tiny mono" style="word-break:break-all;"></span>
          </div>
          <div class="btns">
            <button id="btnConnect">Connect</button>
            <button id="btnDisconnect">Disconnect</button>
            <button id="btnClear">Clear Data</button>
          </div>
        </div>

        <!-- AVG Line/Label Toggles -->
        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Distribution AVG Line/Label</div>
          <div class="btns">
            <label style="display:flex;align-items:center;gap:8px;">
              <input type="checkbox" id="showAvgLine" checked>
              Show AVG Line
            </label>
            <label style="display:flex;align-items:center;gap:8px;">
              <input type="checkbox" id="showAvgLabel">
              Show AVG Label
            </label>
          </div>
        </div>
        <!-- Windows/Peaks/GNSS -->
        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Windows, Peaks & GNSS</div>
          <div class="grid">
            <div style="grid-column:1/-1;">
              <label>Timeseries View Window (seconds)</label>
              <div class="range-row">
                <input id="viewSecRange" type="range" min="5" max="600" step="5" value="30"/>
                <input id="viewSec" type="number" min="5" max="600" step="5" value="30" style="width:90px"/>
              </div>
            </div>
            <div style="grid-column:1/-1;">
              <label>Analysis Window (seconds) — peak detection</label>
              <div class="range-row">
                <input id="winSecRange" type="range" min="5" max="600" step="5" value="30"/>
                <input id="winSec" type="number" min="5" max="600" step="5" value="30" style="width:90px"/>
              </div>
            </div>
            <div><label>Min peak distance (ms)</label><input id="minDist" value="300"/></div>
            <div><label>Min prominence (deg)</label><input id="minProm" value="5.0"/></div>
            <div style="grid-column:1/-1;">
              <label>Velocity smoothing window (seconds)</label>
              <div class="range-row">
                <input id="sogWinRange" type="range" min="3" max="30" step="1" value="8"/>
                <input id="sogWin" type="number" min="3" max="30" step="1" value="8" style="width:90px"/>
              </div>
              <div class="tiny">Speed is computed from a linear fit of XY position over this window (1 Hz GNSS-friendly).</div>
            </div>

            <!-- KDE smoothing controls -->
            <div style="grid-column:1/-1;">
              <label>Distribution smoothing — Roll/Pitch (× bandwidth)</label>
              <div class="range-row">
                <input id="kdeFactorAngRange" type="range" min="0.1" max="1" step="0.1" value="0.3"/>
                <input id="kdeFactorAng" type="number" min="0.1" max="1" step="0.1" value="0.3" style="width:90px"/>
              </div>
            </div>
            <div style="grid-column:1/-1;">
              <label>Distribution smoothing — Frequency (× bandwidth)</label>
              <div class="range-row">
                <input id="kdeFactorFreqRange" type="range" min="0.1" max="1" step="0.1" value="0.3"/>
                <input id="kdeFactorFreq" type="number" min="0.1" max="1" step="0.1" value="0.3" style="width:90px"/>
              </div>
            </div>
            <!-- END -->
          </div>
        </div>

        <!-- Units Configuration -->
        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Athlete Configuration</div>
          <div id="unitsConfig" class="grid" style="grid-template-columns:1fr;gap:12px">
            <!-- Dynamic content here -->
          </div>
          <div class="btns" style="margin-top:12px;">
            <button id="saveUnitConfig">Save Configuration</button>
          </div>
          <div id="configStatus" class="small" style="margin-top:8px;"></div>
        </div>

        <!-- Units Visibility -->
        <div class="card half">
          <div style="font-weight:700;margin-bottom:8px;">Units Visibility</div>
          <div id="unitsList" class="grid" style="grid-template-columns:1fr;gap:8px"></div>
        </div>


        <!-- Race Setup (moved here) -->
        <div class="card grow">
          <div style="font-weight:700;margin-bottom:8px;">Race Setup</div>
          <div class="btns">
            <button id="btnTopMark">Add Top Mark</button>
            <button id="btnStartLine">Add Start Line</button>
          </div>
          <div class="small" id="topMarkInfo" style="margin-top:6px;">No top mark set.</div>
          <div class="small" id="startLineInfo">No start line set.</div>
          <div class="tiny" style="margin-top:6px;">Tip: After clicking a button, you’ll be taken to the Map; click the point(s) to place. First start-line point appears immediately.</div>
        </div>

        <!-- Logs -->
        <div class="card grow"><div style="font-weight:700;margin-bottom:8px;">Logs</div><pre class="log" id="log"></pre></div>
      </div>
    </section>
  </div>

<script>
// --- Stay Awake Mode ---
let stayAwakeMode = false;
let stayAwakeExitSequence = [];
let stayAwakeTimeout = null;
let stayAwakeOverlay = null;
let stayAwakePaused = false;

function enterStayAwakeMode() {
  if (stayAwakeMode) return;
  stayAwakeMode = true;
  stayAwakePaused = livePlottingEnabled;
  livePlottingEnabled = false;
  if (plotTimer) clearInterval(plotTimer);
  // Create overlay
  stayAwakeOverlay = document.createElement('div');
  stayAwakeOverlay.id = 'stayAwakeOverlay';
  Object.assign(stayAwakeOverlay.style, {
    position: 'fixed', left: 0, top: 0, width: '100vw', height: '100vh',
    background: '#000', color: '#fff', zIndex: 9999, display: 'flex', flexDirection: 'column',
    alignItems: 'center', justifyContent: 'center',
  });
  const msg = document.createElement('div');
  msg.textContent = 'Stay Awake Mode';
  msg.style.marginBottom = '32px';
  msg.style.fontSize = '2em';
  msg.style.letterSpacing = '0.05em';
  msg.style.opacity = '0.7';
  stayAwakeOverlay.appendChild(msg);
  // Add exit buttons
  const btnRow = document.createElement('div');
  btnRow.style.display = 'flex';
  btnRow.style.gap = '24px';
  for (let i = 1; i <= 3; i++) {
    const b = document.createElement('button');
    b.textContent = i;
    b.style.fontSize = '2em';
    b.style.width = '64px';
    b.style.height = '64px';
    b.style.borderRadius = '50%';
    b.style.border = '2px solid #fff';
    b.style.background = '#111';
    b.style.color = '#fff';
    b.style.cursor = 'pointer';
    b.onclick = () => stayAwakeButtonPress(i);
    btnRow.appendChild(b);
  }
  stayAwakeOverlay.appendChild(btnRow);
  // Add info
  const info = document.createElement('div');
  info.id = 'stayAwakeInfo';
  info.style.marginTop = '32px';
  info.style.fontSize = '1.1em';
  info.style.opacity = '0.6';
  info.textContent = 'Press 1, 2, 3 in order within 5 seconds to exit.';
  stayAwakeOverlay.appendChild(info);
  document.body.appendChild(stayAwakeOverlay);
  // Prevent screen sleep (if supported)
  if ('wakeLock' in navigator) {
    navigator.wakeLock.request('screen').catch(()=>{});
  }
  // Pause all UI updates except logging (logging assumed to be background)
}

function stayAwakeButtonPress(n) {
  stayAwakeExitSequence.push(n);
  if (stayAwakeExitSequence.length === 1) {
    // Start/reset timer
    if (stayAwakeTimeout) clearTimeout(stayAwakeTimeout);
    stayAwakeTimeout = setTimeout(resetStayAwakeSequence, 5000);
  }
  if (stayAwakeExitSequence.length === 3) {
    if (stayAwakeExitSequence[0] === 1 && stayAwakeExitSequence[1] === 2 && stayAwakeExitSequence[2] === 3) {
      exitStayAwakeMode();
    } else {
      resetStayAwakeSequence();
      document.getElementById('stayAwakeInfo').textContent = 'Wrong sequence. Try again.';
      setTimeout(()=>{
        document.getElementById('stayAwakeInfo').textContent = 'Press 1, 2, 3 in order within 5 seconds to exit.';
      }, 1200);
    }
  }
}
function resetStayAwakeSequence() {
  stayAwakeExitSequence = [];
  if (stayAwakeTimeout) clearTimeout(stayAwakeTimeout);
  stayAwakeTimeout = null;
}
function exitStayAwakeMode() {
  stayAwakeMode = false;
  resetStayAwakeSequence();
  if (stayAwakeOverlay) {
    stayAwakeOverlay.remove();
    stayAwakeOverlay = null;
  }
  // Resume UI updates if they were enabled before
  if (stayAwakePaused) {
    livePlottingEnabled = true;
    startPlotTimer();
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('btnStayAwake');
  if (btn) {
    btn.onclick = enterStayAwakeMode;
  }
});

const APP_VERSION="v1.5.9";
const ENCRYPTED_CREDS="eyJzYWx0IjoiYU01amVaRG9rd0o5dmVDc1gwTjhoQT09IiwiaXYiOiJuTEdVM2NldmhSSGFVR2ZmIiwiY3QiOiIzeVZaUkxnRUNxaWxicU92QmExZlJkcVZUb1ZiM3NvZFArd2svK3FxTW9NZGRYZHV5V2gveTV3WmVxakZlZkV6L2ZpZjN6SEpqU3Z0TXd2OCJ9";
const $=id=>document.getElementById(id);

// ---------- utilities ----------
function log(s){const el=$('log');el.textContent+=s+"\\n";el.scrollTop=el.scrollHeight}
function setStatus(t,ok=false){$('status').textContent=t;$('status').className=ok?'ok':'bad'}
function meanStd(a){if(!a.length)return{mean:NaN,std:NaN};const m=a.reduce((x,y)=>x+y,0)/a.length;const v=a.reduce((x,y)=>x+(y-m)*(y-m),0)/a.length;return{mean:m,std:Math.sqrt(v)}}
function fmt2(n){return n.toString().padStart(2,'0')}
const b64d=b64=>Uint8Array.from(atob(b64),c=>c.charCodeAt(0));
async function deriveKey(pw,salt){const enc=new TextEncoder();const mat=await crypto.subtle.importKey('raw',enc.encode(pw),'PBKDF2',false,['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},mat,{name:'AES-GCM',length:256},false,['encrypt','decrypt'])}
async function decryptCreds(pass,blob){const j=JSON.parse(atob(blob));const key=await deriveKey(pass,b64d(j.salt));const pt=await crypto.subtle.decrypt({name:'AES-GCM',iv:b64d(j.iv)},key,b64d(j.ct));return JSON.parse(new TextDecoder().decode(new Uint8Array(pt)))}
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

// color helpers
function hexToRgb(h){h=h.replace('#',''); if(h.length===3){h=h.split('').map(c=>c+c).join('');} const n=parseInt(h,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};}
function rgbToHex({r,g,b}){const f=v=>v.toString(16).padStart(2,'0'); return '#'+f(r)+f(g)+f(b);}
function rgbToHsl({r,g,b}){r/=255;g/=255;b/=255;const max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,l=(max+min)/2;if(max===min){h=s=0;}else{const d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return {h,s,l};}
function hslToRgb({h,s,l}){let r,g,b;if(s===0){r=g=b=l;}else{const hue2rgb=(p,q,t)=>{if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;};const q=l<0.5?l*(1+s):l+s-l*s;const p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return {r:Math.round(r*255),g:Math.round(g*255),b:Math.round(b*255)};}
function darkenHex(hex, amt=0.22){const hsl=rgbToHsl(hexToRgb(hex)); const l=Math.max(0, hsl.l*(1-amt)); return rgbToHex(hslToRgb({...hsl,l}));}
function cssVar(name, fallback='#ffaa00'){return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback;}

// ---------- chart defaults ----------
Chart.defaults.color='#000000'; Chart.defaults.borderColor='#e0e0e0';

function applyChartDefaults() {
  const chartText = cssVar('--chart-text');
  const chartGrid = cssVar('--chart-grid');
  Chart.defaults.color = chartText;
  Chart.defaults.borderColor = chartGrid;

  // Map tiles + credit
  const url = 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';
  const credit = 'Basemap © OpenStreetMap, © CARTO — Positron';

  if(map){
    if(window._tileLayer) map.removeLayer(window._tileLayer);
    window._tileLayer = L.tileLayer(url, {attribution:'&copy; OSM & CARTO', subdomains:'abcd', maxZoom:20});
    window._tileLayer.addTo(map);
    if(topMarkLayer){
      const accent = cssVar('--accent','#ffcc00');
      topMarkLayer.setStyle({color:accent, fillColor:accent});
    }
    if(startLineLayer){
      const accent = cssVar('--accent','#ffcc00');
      startLineLayer.setStyle({color:accent, opacity:0.9, weight:3});
      if(startLineMarkers.a) startLineMarkers.a.setStyle({color:accent, fillColor:accent});
      if(startLineMarkers.b) startLineMarkers.b.setStyle({color:accent, fillColor:accent});
    }
  }
  const mc = $('mapCredit'); if(mc) mc.textContent = credit;
}

// ---------- state ----------
let client=null, unlocked=false, viewer={user:null,pass:null};
let chartTS=null, chartSOG=null;
let map=null, mapInited=false, firstMapFixDone=false;
let globalT0=null;

// top mark state
let topMark=null; // {lat,lon}
let topMarkLayer=null;

// start line state
let startLine=null; // {a:{lat,lon}, b:{lat,lon}}
let startLineLayer=null;
let startLineMarkers={a:null,b:null};
let placingStartPhase=0; // 0 idle, 1 awaiting A, 2 awaiting B

// Athlete colors and configurations
const COLORS_PALETTE = [
  { name: 'Blue', value: '#4cc9f0' },
  { name: 'Gold', value: '#ffd166' },
  { name: 'Red', value: '#ef476f' },
  { name: 'Emerald', value: '#06d6a0' },
  { name: 'Purple', value: '#9b5de5' },
  { name: 'Orange', value: '#ff9f1c' },
  { name: 'Teal', value: '#00b4d8' },
  { name: 'Pink', value: '#ff70a6' }
];

let COLORS_BASE = COLORS_PALETTE.slice(0, 4).map(c => c.value); // Default first 4 colors
const UNIT_CONFIG_KEY = 'unitColors';

// Load saved unit configurations
function loadUnitConfig() {
  try {
    const saved = localStorage.getItem(UNIT_CONFIG_KEY);
    return saved ? JSON.parse(saved) : {};
  } catch(e) {
    console.warn('Failed to load unit config:', e);
    return {};
  }
}

// Save unit configurations
function saveUnitConfig() {
  const config = {};
  const configRows = document.querySelectorAll('.unit-config-row');
  configRows.forEach(row => {
    const unitId = row.dataset.unit;
    const customName = row.querySelector('.unit-custom-name').value;
    const color = row.querySelector('.unit-color').value;
    if (unitId) {
      config[unitId] = { customName, name: customName, color };
    }
  });
  
  try {
    localStorage.setItem(UNIT_CONFIG_KEY, JSON.stringify(config));
    // Update any visible reports with new colors
    const activeReportBtn = document.querySelector('#reportsTabs .tabbtn.active');
    if (activeReportBtn) {
      showReportFor(activeReportBtn.dataset.recId);
    }
    const status = document.getElementById('configStatus');
    status.textContent = 'Configuration saved successfully';
    status.style.color = '#16c26e';
    setTimeout(() => status.textContent = '', 3000);
    return true;
  } catch(e) {
    console.warn('Failed to save unit config:', e);
    const status = document.getElementById('configStatus');
    status.textContent = 'Failed to save configuration';
    status.style.color = '#ff6b6b';
    return false;
  }
}

// Update unit config row or create new one
function updateUnitConfigRow(unitId) {
  const container = document.getElementById('unitsConfig');
  if (!container) return;

  let row = container.querySelector(`.unit-config-row[data-unit="${unitId}"]`);
  const config = loadUnitConfig();
  const savedConfig = config[unitId] || {};
  
  if (!row) {
    row = document.createElement('div');
    row.className = 'unit-config-row';
    row.dataset.unit = unitId;
    row.style.display = 'grid';
    row.style.gridTemplateColumns = 'minmax(80px, 1fr) minmax(120px, 1.5fr) minmax(100px, 1fr)';
    row.style.gap = '8px';
    row.style.alignItems = 'center';
    
    // Original name label
    const origLabel = document.createElement('div');
    origLabel.className = 'small';
    origLabel.textContent = unitId;
    row.appendChild(origLabel);

    // Custom name input
    const nameInput = document.createElement('input');
    nameInput.className = 'unit-custom-name';
    nameInput.type = 'text';
    nameInput.placeholder = 'Custom name';
    nameInput.value = savedConfig.customName || '';
    row.appendChild(nameInput);

    // Color select
    const colorSelect = document.createElement('select');
    colorSelect.className = 'unit-color';
    COLORS_PALETTE.forEach(color => {
      const opt = document.createElement('option');
      opt.value = color.value;
      opt.textContent = color.name;
      if (color.value === (savedConfig.color || COLORS_BASE[discoveredOrder.indexOf(unitId) % COLORS_BASE.length])) {
        opt.selected = true;
      }
      colorSelect.appendChild(opt);
    });
    row.appendChild(colorSelect);

    container.appendChild(row);
  }
}

// Apply configuration to a unit
function applyUnitConfig(unitId) {
  const config = loadUnitConfig();
  const savedConfig = config[unitId];
  if (savedConfig) {
    const unit = units[unitId];
    if (unit) {
      const displayName = savedConfig.customName || unitId;
      unit.baseColor = savedConfig.color;
      unit.customName = displayName;
      // Update any displayed elements
      const tagNow = document.getElementById(`tag-${unitId}`);
      const tagSet = document.getElementById(`tag-${unitId}-settings`);
      if (tagNow) tagNow.textContent = displayName;
      if (tagSet) tagSet.textContent = unit.customName;

      // Update chart labels
      if (chartTS) {
        if (unit.idxRoll != null) chartTS.data.datasets[unit.idxRoll].label = `${unit.customName} roll`;
        if (unit.idxPitch != null) chartTS.data.datasets[unit.idxPitch].label = `${unit.customName} pitch`;
        if (unit.idxRollPk != null) chartTS.data.datasets[unit.idxRollPk].label = `${unit.customName} roll peaks`;
        if (unit.idxPitchPk != null) chartTS.data.datasets[unit.idxPitchPk].label = `${unit.customName} pitch peaks`;
        chartTS.update('none');
      }
      
      // Update SOG chart labels
      if (chartSOG) {
        if (unit.idxSOG != null) chartSOG.data.datasets[unit.idxSOG].label = `${unit.customName} SOG`;
        if (unit.idxVMG != null) chartSOG.data.datasets[unit.idxVMG].label = `${unit.customName} VMG`;
        chartSOG.update('none');
      }

      // Update distribution chart labels
      if (distCharts.roll) {
        const rI = distIdx.roll[unitId];
        if (rI != null) {
          distCharts.roll.data.datasets[rI].label = unit.customName;
          distCharts.roll.update('none');
        }
      }
      if (distCharts.pitch) {
        const pI = distIdx.pitch[unitId];
        if (pI != null) {
          distCharts.pitch.data.datasets[pI].label = unit.customName;
          distCharts.pitch.update('none');
        }
      }
      if (distCharts.freq) {
        const fI = distIdx.freq[unitId];
        if (fI != null) {
          distCharts.freq.data.datasets[fI].label = unit.customName;
          distCharts.freq.update('none');
        }
      }

      // Update sync selector
      if (syncOpt) syncOpt.textContent = unit.customName;

      refreshUnitStylesForTheme();
    }
  }
}

function themedColor(hex){ return hex; }

const units={}, discoveredOrder=[];
const MAX_KEEP_SEC=600, FREQ_HOLD_MS=2000, GNSS_KEEP=4000;

// windows
const sogRange=$('sogWinRange'), sogNum=$('sogWin');
function getSogWinSec(){ return clamp(parseInt(sogNum.value||'8',10),3,30); }
sogRange.addEventListener('input',e=>sogNum.value=e.target.value);
sogNum.addEventListener('change',e=>sogRange.value=e.target.value);

// KDE smoothing controls
const kdeAngRange=$('kdeFactorAngRange'), kdeAngNum=$('kdeFactorAng');
const kdeFreqRange=$('kdeFactorFreqRange'), kdeFreqNum=$('kdeFactorFreq');
function getKdeFactorAngles(isRoll=false){ 
  const val = clamp(parseFloat(kdeAngNum.value||'0.3'),0.1,1);
  return isRoll ? val * 1 : val; // Use half the smoothing for roll
}
function getKdeFactorFreq(){ return clamp(parseFloat(kdeFreqNum.value||'0.3'),0.1,1); }
kdeAngRange.addEventListener('input',e=>{ kdeAngNum.value=e.target.value; updateUnifiedDistributions(); });
kdeAngNum.addEventListener('change',e=>{ kdeAngRange.value=e.target.value; updateUnifiedDistributions(); });
kdeFreqRange.addEventListener('input',e=>{ kdeFreqNum.value=e.target.value; updateUnifiedDistributions(); });
kdeFreqNum.addEventListener('change',e=>{ kdeFreqRange.value=e.target.value; updateUnifiedDistributions(); });

// sync

// recording
let recActive=false, recRows=[], recStartedAt=null;

// DOM refs
const nowUnits=$('nowUnits'), unitsList=$('unitsList');

// ---------- chart builders ----------
function makeTimeseries(){
  const ctx=document.getElementById('chart_ts').getContext('2d');
  return new Chart(ctx,{type:'line',data:{datasets:[]},options:{
    animation:false,responsive:true,maintainAspectRatio:false,
    scales:{
      x:{type:'linear',title:{display:true,text:'time (s from start)'},ticks:{callback:v=>Number(v).toFixed(1)}},
      y:{title:{display:true,text:'degrees'},min:-40,max:40}
    },
    plugins:{legend:{position:'bottom'}}
  }});
}
function makeSOG(){
  const ctx=document.getElementById('chart_sog').getContext('2d');
  return new Chart(ctx,{type:'line',data:{datasets:[]},options:{
    animation:false,responsive:true,maintainAspectRatio:false,
    scales:{
      x:{type:'linear',title:{display:true,text:'time (s from start)'},ticks:{callback:v=>Number(v).toFixed(1)}},
      y:{title:{display:true,text:'knots'},min:-8,max:8}
    },
    plugins:{legend:{position:'bottom'}}
  }});
}
function makeMap(){
  map=L.map('map',{zoomControl:true});
  window._tileLayer=null; // set by applyTheme()
  map.setView([0,0],2); mapInited=true;
}
function fitMapIfFirst(lat,lon){ if(!firstMapFixDone){ map.setView([lat,lon],15); firstMapFixDone=true; } }

// ---------- KDE helpers ----------
function linspace(min,max,n){ const a=new Array(n); const step=(max-min)/(n-1); for(let i=0;i<n;i++) a[i]=min+i*step; return a; }
function stddev(arr){ if(!arr.length) return 0; const m=arr.reduce((s,v)=>s+v,0)/arr.length; return Math.sqrt(arr.reduce((s,v)=>s+(v-m)*(v-m),0)/arr.length); }
function kdeBandwidth(arr){ if(arr.length<2) return 1; const s=stddev(arr); return 1.06*s*Math.pow(arr.length,-1/5); }
function gaussian(u){ return Math.exp(-0.5*u*u)/Math.sqrt(2*Math.PI); }

/* Log-KDE for positive variables (frequency) */
function kdeOnGridLogBack(values, xs, factor=1){
  const v = (values || []).filter(Number.isFinite).filter(x => x > 0);
  if (!v.length) return xs.map(_ => 0);
  const y = v.map(Math.log);
  let h = kdeBandwidth(y) * factor;
  if (!Number.isFinite(h) || h <= 1e-6) {
    const ymin = Math.min(...y), ymax = Math.max(...y);
    const span = (ymax - ymin) || 1;
    h = Math.max(span * 0.05, 1e-3) * factor;
  }
  const n = y.length;
  const invnh = 1 / (n * h);
  const out = new Array(xs.length);
  for (let j = 0; j < xs.length; j++) {
    const x = Math.max(xs[j], 1e-9);
    const yl = Math.log(x);
    let s = 0;
    for (let i = 0; i < n; i++) s += gaussian((yl - y[i]) / h);
    out[j] = (s * invnh) / x;
  }
  return out;
}

/* Shift→log→back for angles (allows negatives, returns full range) */
function kdeOnGridLogBackShift(values, xs, factor=1){
  const v0 = (values || []).filter(Number.isFinite);
  if (!v0.length) return xs.map(_ => 0);
  const minV = Math.min(...v0);
  const minX = Math.min(...xs);
  const eps = 1e-6;
  const C = Math.max( -(minV) + eps, -(minX) + eps );
  const v = v0.map(x => x + C);
  const xsShift = xs.map(x => x + C);
  const y = v.map(Math.log);
  let h = kdeBandwidth(y) * factor;
  if (!Number.isFinite(h) || h <= 1e-6) {
    const ymin = Math.min(...y), ymax = Math.max(...y);
    const span = (ymax - ymin) || 1;
    h = Math.max(span * 0.05, 1e-3) * factor;
  }
  const n = y.length;
  const invnh = 1 / (n * h);
  const out = new Array(xsShift.length);
  for (let j = 0; j < xsShift.length; j++) {
    const z = Math.max(xsShift[j], eps);
    const yl = Math.log(z);
    let s = 0;
    for (let i = 0; i < n; i++) s += gaussian((yl - y[i]) / h);
    out[j] = (s * invnh) / z;
  }
  return out;
}

const points=(xs,ys)=>xs.map((x,i)=>({x,y:ys[i]}));

// Helper function for zero line annotation
// General function to add a dotted average line with AVG label in athlete color
// showLine: show/hide the vertical line, showLabel: show/hide the label
function addAvgLineToDistribChart(chart, avg, color, labelText, showLine = true, showLabel = true) {
  if (!chart || !chart.options.plugins) return;
  if (!chart.options.plugins.annotation) chart.options.plugins.annotation = {};
  // Use labelText if provided, otherwise use color as a unique key (since color is per athlete)
  // If both are undefined, fallback to avg value
  let annId = 'avgline_';
  if (labelText) {
    annId += labelText.replace(/[^a-zA-Z0-9]/g, '');
  } else if (color) {
    annId += color.replace(/[^a-zA-Z0-9]/g, '');
  } else {
    annId += String(avg).replace(/[^a-zA-Z0-9]/g, '');
  }
  if (chart.options.plugins.annotation.annotations && chart.options.plugins.annotation.annotations[annId]) {
    delete chart.options.plugins.annotation.annotations[annId];
  }
  if (!chart.options.plugins.annotation.annotations) chart.options.plugins.annotation.annotations = {};
  chart.options.plugins.annotation.annotations[annId] = {
    type: 'line',
    xMin: avg,
    xMax: avg,
    borderColor: showLine ? color : 'rgba(0,0,0,0)',
    borderWidth: showLine ? 2 : 0,
    borderDash: [6, 6],
    label: {
      display: !!showLabel,
      content: 'AVG  ' + avg.toFixed(2),
      color: color,
      backgroundColor: 'rgba(0,0,0,0)',
      position: 'bottom',
      yAdjust: 40,
      font: {size: 12 },
      padding: 0,
      cornerRadius: 0,
      borderWidth: 0,
      borderRadius: 0,
      textAlign: 'center',
      xAdjust: 0
    },
    z: 20
  };
  chart.update('none');
}
function red_zero_line() {
  return {
    annotations: {
      zeroline: {
        type: 'line',
        xMin: 0,
        xMax: 0,
        borderColor: '#ff0000',
        borderWidth: 1
      }
    }
  };
}

// multi-dataset density chart
function makeDensityChartMulti(ctx, label, xConf){
  const {min,max,step,type='linear'}=xConf;
  return new Chart(ctx,{
    type:'line',
    data:{datasets:[]},
    options:{
      responsive:true, maintainAspectRatio:false, animation:false,
      layout:{padding:{left:10,right:10,bottom:8,top:4}},
      scales:{
        x:{ type, min, max,
            grid:{color:Chart.defaults.borderColor,tickLength:4},
            ticks:{
              color:Chart.defaults.color,
              padding:6,
              maxRotation:0,
              minRotation:0,
              callback:(v)=>String(v),
              values: [-40, -30, -20, -10, 0, 10, 20, 30, 40]
            }
          },
        y:{min:0, max:110, grid:{color:Chart.defaults.borderColor,tickLength:4}, ticks:{display:false}}
      },
      plugins:{
        legend:{position:'bottom',labels:{boxWidth:10,boxHeight:10,usePointStyle:true,pointStyle:'line'}},
        tooltip:{mode:'index',intersect:false,callbacks:{label:(ctx)=>`${ctx.dataset.label}: ${Math.round(ctx.parsed.y)}%`}},
        annotation: red_zero_line()
      },
      elements:{line:{tension:0.25,borderWidth:2}, point:{radius:0}}
    }
  });
}
function upsertDistDataset(chart, map, unitId, color){
  if(map[unitId]!=null) return map[unitId];
  const ds={label:unitId,data:[],parsing:true,borderColor:color,backgroundColor:color+'22',fill:true};
  chart.data.datasets.push(ds);
  const idx=chart.data.datasets.length-1;
  map[unitId]=idx;
  return idx;
}

// ---------- distributions state ----------
const DEG_RANGE={min:-40,max:40,step:10,gridCnt:160};
const FREQ_RANGE={min:0.01,max:5,step:1,gridCnt:200};
let distCharts={roll:null,pitch:null,freq:null, xsDeg:null, xsHz:null};
let distIdx={roll:{},pitch:{},freq:{}};

// ---------- timeseries & SOG ----------
function makeTS(){ return makeTimeseries(); }
function makeSOGChart(){ return makeSOG(); }

// ---------- unit management ----------
function ensureUnit(unitId){
  if(units[unitId]) return units[unitId];
  // Only allow up to eight athletes
  if (discoveredOrder.length >= 8 && !units[unitId]) {
    log('Maximum of eight athletes supported. Additional units will not be shown.');
    return null;
  }
  
  const idx = discoveredOrder.length;
  const config = loadUnitConfig()[unitId];
  const baseColor = config ? config.color : COLORS_BASE[idx % COLORS_BASE.length];
  const customName = config ? config.customName || unitId : unitId;
  const color = baseColor; discoveredOrder.push(unitId);
  
  // Create or update configuration row
  updateUnitConfigRow(unitId);

  // Create base unit object
  const u = units[unitId] = {baseColor, color, customName, originalName: unitId,
    visible: true,
    times: [], roll: [], pitch: [],
    seriesRoll: [], seriesPitch: [],
    seriesRollPk: [], seriesPitchPk: [],
    gnssLatLngs: [], lat0: null, lon0: null, posBuf: [],
    sogEMA: null, heading: null, sogTimes: [], sogVals: [], sogSeries: [],
    vmgTimes: [], vmgVals: [], vmgSeries: [],
    vx: null, vy: null,
    idxRoll: null, idxPitch: null, idxRollPk: null, idxPitchPk: null, idxSOG: null, idxVMG: null,
    poly: null, marker: null, nowElems: {}, statsElems: {},
    lastRollHz: NaN, lastRollAt: 0, lastPitchHz: NaN, lastPitchAt: 0
  };

  // timeseries datasets
  const rollDs = {label: `${customName} roll`, data: u.seriesRoll, parsing: false, borderColor: color, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, tension: .15, spanGaps: true};
  const pitchDs = {label: `${customName} pitch`, data: u.seriesPitch, parsing: false, borderColor: color, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, tension: .15, borderDash: [6,4], spanGaps: true};
  chartTS.data.datasets.push(rollDs); u.idxRoll = chartTS.data.datasets.length - 1;
  chartTS.data.datasets.push(pitchDs); u.idxPitch = chartTS.data.datasets.length - 1;

  // peak markers
  const rollPk = {label: `${customName} roll peaks`, type: 'scatter', data: u.seriesRollPk, parsing: false, backgroundColor: color, borderColor: color, pointRadius: 4, pointStyle: 'circle', showLine: false};
  const pitchPk = {label: `${customName} pitch peaks`, type: 'scatter', data: u.seriesPitchPk, parsing: false, backgroundColor: color, borderColor: color, pointRadius: 4, pointStyle: 'circle', showLine: false};
  chartTS.data.datasets.push(rollPk); u.idxRollPk = chartTS.data.datasets.length - 1;
  chartTS.data.datasets.push(pitchPk); u.idxPitchPk = chartTS.data.datasets.length - 1;

  // SOG dataset
  const sogDs = {label: `${customName} SOG`, data: u.sogSeries, parsing: false, borderColor: color, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, tension: .15, spanGaps: true};
  chartSOG.data.datasets.push(sogDs); u.idxSOG = chartSOG.data.datasets.length - 1;

  // VMG dataset (dashed)
  const vmgDs = {label: `${customName} VMG`, data: u.vmgSeries, parsing: false, borderColor: color, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, tension: .15, spanGaps: true, borderDash: [4,4]};
  chartSOG.data.datasets.push(vmgDs); u.idxVMG = chartSOG.data.datasets.length - 1;

  // map layers
  u.poly = L.polyline([], {color, weight: 3, opacity: 0.95}).addTo(map);
  u.marker = L.circleMarker([0,0], {radius: 6, color, fillColor: color, fillOpacity: 1}).addTo(map);
  u.poly.setStyle({opacity: 0}); u.marker.setStyle({opacity: 0, fillOpacity: 0});

  // Now card (+ distances)
  const nowCard = document.createElement('div');
  nowCard.className = 'unitNow uNums';
  nowCard.style.setProperty('--ucolor', color);
  // Add refresh rate indicator in top right (dynamic)
  nowCard.innerHTML = `
    <div style="display:flex;justify-content:space-between;align-items:flex-start;">
      <div class="unitTag" id="tag-${unitId}" style="background:${color}">${customName}</div>
      <div class="tiny" id="refresh-hz-${unitId}" style="font-size:10px;opacity:0.7;align-self:flex-start;">– Hz</div>
    </div>
    <div class="grid" style="grid-template-columns:1fr 1fr">
      <div><div class="small">Roll</div><div class="num" id="now-roll-${unitId}">–</div></div>
      <div><div class="small">Pitch</div><div class="num" id="now-pitch-${unitId}">–</div></div>
      <div><div class="small">Freq (Hz)</div><div class="num" id="now-hz-${unitId}">–</div></div>
      <div><div class="small">Heading (°)</div><div class="num" id="now-hdg-${unitId}">–</div></div>
      <div><div class="small">SOG (kt)</div><div class="num" id="now-sog-${unitId}">–</div></div>
      <div><div class="small">VMG (kt)</div><div class="num" id="now-vmg-${unitId}">–</div></div>
      <div><div class="small">Dist→Start (m)</div><div class="num" id="now-dstart-${unitId}">–</div></div>
      <div><div class="small">Dist→Top (m)</div><div class="num" id="now-dtop-${unitId}">–</div></div>
      <div style="grid-column:1/-1"><div class="small">Lat, Lon</div><div class="small mono" id="now-ll-${unitId}">–</div></div>
    </div>`;
  nowUnits.appendChild(nowCard);
  u.nowElems = { roll: $(`now-roll-${unitId}`), pitch: $(`now-pitch-${unitId}`), hz: $(`now-hz-${unitId}`),
               sog: $(`now-sog-${unitId}`), vmg: $(`now-vmg-${unitId}`), sogMean: $(`now-sogmean-${unitId}`),
               hdg: $(`now-hdg-${unitId}`), ll: $(`now-ll-${unitId}`),
               dStart: $(`now-dstart-${unitId}`), dTop: $(`now-dtop-${unitId}`),
               refreshHz: $(`refresh-hz-${unitId}`) };
// Update refresh rate for each athlete tile in Now
setInterval(() => {
  for (const id of Object.keys(units)) {
    const u = units[id];
    if (!u.nowElems || !u.nowElems.refreshHz) continue;
    const times = u.times;
    let hz = '–';
    if (times && times.length >= 2) {
      const dt = times[times.length - 1] - times[times.length - 2];
      if (dt > 0 && dt < 10000) hz = (1000 / dt).toFixed(1);
    }
    u.nowElems.refreshHz.textContent = hz + ' Hz';
  }
}, 333);

  // Stats card
  const statsCol = document.createElement('div'); statsCol.className = 'card half unitStats'; statsCol.style.setProperty('--ucolor', color);
  statsCol.innerHTML = `<div style="font-weight:700;margin-bottom:8px;"><span class="unitTag" style="background:${color}">${customName}</span> — window stats</div>
    <div class="grid">
      <div><div class="small">Mean Roll</div><div class="num" id="st-roll-mean-${unitId}">–</div></div>
      <div><div class="small">Std Roll</div><div class="num" id="st-roll-std-${unitId}">–</div></div>
      <div><div class="small">Mean Pitch</div><div class="num" id="st-pitch-mean-${unitId}">–</div></div>
      <div><div class="small">Std Pitch</div><div class="num" id="st-pitch-std-${unitId}">–</div></div>
      <div><div class="small">Peaks Roll</div><div class="num" id="st-roll-pk-${unitId}">0</div></div>
      <div><div class="small">Peaks Pitch</div><div class="num" id="st-pitch-pk-${unitId}">0</div></div>
      <div><div class="small">Freq Roll (Hz)</div><div class="num" id="st-roll-hz-${unitId}">–</div></div>
      <div><div class="small">Freq Pitch (Hz)</div><div class="num" id="st-pitch-hz-${unitId}">–</div></div>
      <div style="grid-column:1/-1"><div class="small">Mean SOG (kt)</div><div class="num" id="st-sog-mean-${unitId}">–</div></div>
    </div>`;


  // settings checkbox
  const row = document.createElement('div');
  row.innerHTML = `<label style="display:flex;gap:8px;align-items:center">
    <input type="checkbox" id="chk-${unitId}" checked/>
    <span class="unitTag" id="tag-${unitId}-settings" style="background:${color}">${customName}</span>
    <span class="tiny">show/hide</span><span class="tiny" style="margin-left:8px;">Original: ${unitId}</span></label>`;
  unitsList.appendChild(row);
  row.querySelector('input').addEventListener('change', (e) => {
    u.visible = e.target.checked;
    [u.idxRoll, u.idxPitch, u.idxRollPk, u.idxPitchPk].forEach(i => chartTS.data.datasets[i].hidden = !u.visible);
    [u.idxSOG, u.idxVMG].forEach(i => chartSOG.data.datasets[i].hidden = !u.visible);
    const rI = distIdx.roll[unitId]; if (rI != null) distCharts.roll.data.datasets[rI].hidden = !u.visible;
    const pI = distIdx.pitch[unitId]; if (pI != null) distCharts.pitch.data.datasets[pI].hidden = !u.visible;
    const fI = distIdx.freq[unitId];  if (fI != null) distCharts.freq.data.datasets[fI].hidden = !u.visible;
    chartTS.update('none'); chartSOG.update('none');
    if (distCharts.roll) distCharts.roll.update('none');
    if (distCharts.pitch) distCharts.pitch.update('none');
    if (distCharts.freq)  distCharts.freq.update('none');
  });

  chartTS.update('none'); chartSOG.update('none');
  return u;
}

// apply colors to all unit visuals
function refreshUnitStylesForTheme(){
  for(const id of Object.keys(units)){
    const u=units[id];
    const c = u.baseColor;
    u.color = c;
    chartTS.data.datasets[u.idxRoll].borderColor = c;
    chartTS.data.datasets[u.idxPitch].borderColor = c;
    chartTS.data.datasets[u.idxRollPk].backgroundColor = c;
    chartTS.data.datasets[u.idxRollPk].borderColor = c;
    chartTS.data.datasets[u.idxPitchPk].backgroundColor = c;
    chartTS.data.datasets[u.idxPitchPk].borderColor = c;
    chartSOG.data.datasets[u.idxSOG].borderColor = c;
    chartSOG.data.datasets[u.idxVMG].borderColor = c;
    if(u.poly) u.poly.setStyle({color:c});
    if(u.marker) u.marker.setStyle({color:c, fillColor:c});
    const tagNow = document.getElementById(`tag-${id}`); if(tagNow) tagNow.style.background = c;
    const tagSet = document.getElementById(`tag-${id}-settings`); if(tagSet) tagSet.style.background = c;
    const nowCard = u.nowElems?.roll && document.querySelector(`#now-roll-${id}`)?.closest('.uNums'); if(nowCard) nowCard.style.setProperty('--ucolor', c);
    const statEl = document.querySelector(`#st-roll-mean-${id}`)?.closest('.unitStats'); if(statEl) statEl.style.setProperty('--ucolor', c);
    const rI=distIdx.roll[id]; if(rI!=null){ const ds=distCharts.roll.data.datasets[rI]; ds.borderColor=c; ds.backgroundColor=c+'22'; }
    const pI=distIdx.pitch[id]; if(pI!=null){ const ds=distCharts.pitch.data.datasets[pI]; ds.borderColor=c; ds.backgroundColor=c+'22'; }
    const fI=distIdx.freq[id];  if(fI!=null){ const ds=distCharts.freq.data.datasets[fI]; ds.borderColor=c; ds.backgroundColor=c+'22'; }
  }
}

// ---------- helpers: windows, axes, prune ----------
const viewRange=$('viewSecRange'), viewNum=$('viewSec'); let currentViewSec=parseInt(viewNum.value||'30',10);
function applyViewWindow(val){ currentViewSec=clamp(parseInt(val||'30',10),5,600); viewRange.value=currentViewSec; viewNum.value=currentViewSec; updateAxisRange(); }
viewRange.addEventListener('input',e=>applyViewWindow(e.target.value));
viewNum.addEventListener('change',e=>applyViewWindow(e.target.value));

const winRange=$('winSecRange'), winNum=$('winSec');
function applyWindow(val){ const v=clamp(parseInt(val||'30',10),5,600); winRange.value=v; winNum.value=v; recomputePeaks(); chartTS.update('none'); chartSOG.update('none'); }
winRange.addEventListener('input',e=>applyWindow(e.target.value));
winNum.addEventListener('change',e=>applyWindow(e.target.value));

function updateAxisRange(){
  if(globalT0===null){
    if(chartTS){chartTS.options.scales.x.min=0; chartTS.options.scales.x.max=currentViewSec; chartTS.update('none');}
    if(chartSOG){chartSOG.options.scales.x.min=0; chartSOG.options.scales.x.max=currentViewSec; chartSOG.update('none');}
    return;
  }
  const last=lastPlotT||Date.now();
  const nowSec=(last-globalT0)/1000;
  const xmin=Math.max(0,nowSec-currentViewSec), xmax=Math.max(currentViewSec,nowSec);
  if(chartTS){chartTS.options.scales.x.min=Number(xmin.toFixed(1)); chartTS.options.scales.x.max=Number(xmax.toFixed(1)); chartTS.update('none');}
  if(chartSOG){chartSOG.options.scales.x.min=Number(xmin.toFixed(1)); chartSOG.options.scales.x.max=Number(xmax.toFixed(1)); chartSOG.update('none');}
}

function pruneOld(nowMs){
  const keepMs=Math.max(parseFloat(winNum.value||'30')*1000,MAX_KEEP_SEC*1000);
  for(const id of Object.keys(units)){
    const u=units[id];
    while(u.times.length && u.times[0]<nowMs-keepMs){u.times.shift();u.roll.shift();u.pitch.shift();}
    while(u.seriesRoll.length && (globalT0 + u.seriesRoll[0].x*1000) < nowMs-keepMs){u.seriesRoll.shift();u.seriesPitch.shift();}
    while(u.gnssLatLngs.length>GNSS_KEEP){u.gnssLatLngs.shift(); if(u.poly) u.poly.setLatLngs(u.gnssLatLngs);}
    while(u.posBuf.length && u.posBuf[0].t < nowMs - getSogWinSec()*1000){u.posBuf.shift();}
    while(u.sogTimes.length && u.sogTimes[0]<nowMs-keepMs){u.sogTimes.shift();u.sogVals.shift();}
    while(u.sogSeries.length && (globalT0 + u.sogSeries[0].x*1000) < nowMs-keepMs){u.sogSeries.shift();}
    while(u.vmgTimes.length && u.vmgTimes[0]<nowMs-keepMs){u.vmgTimes.shift();u.vmgVals.shift();}
    while(u.vmgSeries.length && (globalT0 + u.vmgSeries[0].x*1000) < nowMs-keepMs){u.vmgSeries.shift();}
  }
}

// ---------- peaks & stats + distributions ----------
function detectPeaks(vals,times,minDistMs,minProm){
  const n=vals.length; if(n<3) return [];
  const peaks=[]; let lastT=-1e18;
  for(let i=1;i<n-1;i++){
    const v=vals[i]; if(v<=vals[i-1]||v<=vals[i+1]) continue;
    const w=5,i0=Math.max(0,i-w),i1=Math.min(n-1,i+w);
    let base=vals[i0]; for(let j=i0+1;j<=i1;j++) base=Math.min(base,vals[j]);
    if(v-base<minProm) continue;
    const t=times[i]; if(t-lastT<minDistMs) continue;
    peaks.push({t,v,i}); lastT=t;
  }
  return peaks;
}
function getWindowForUnit(u, winSec){
  if(!u.times.length) return {tWin:[], rWin:[], pWin:[], startMs:NaN, nowU:NaN};
  const nowU=u.times[u.times.length-1], startMs=nowU - winSec*1000;
  let s=0; while(s<u.times.length && u.times[s]<startMs) s++;
  return { tWin:u.times.slice(s), rWin:u.roll.slice(s), pWin:u.pitch.slice(s), startMs, nowU };
}
function freqSamplesFromPeaks(peaks){
  const out=[];
  for(let i=1;i<peaks.length;i++){
    const dt=(peaks[i].t-peaks[i-1].t)/1000;
    if(dt>0){ const f=1/dt; if(f>=FREQ_RANGE.min && f<=FREQ_RANGE.max) out.push(f); }
  }
  return out;
}
function updateUnifiedDistributions(){
  if(!distCharts.roll||!distCharts.pitch||!distCharts.freqRoll||!distCharts.freqPitch) return;
  const winSec=parseFloat(winNum.value||'30');

  if(!distCharts.xsDeg){ distCharts.xsDeg=linspace(DEG_RANGE.min,DEG_RANGE.max,DEG_RANGE.gridCnt); }
  if(!distCharts.xsHz){  distCharts.xsHz =linspace(FREQ_RANGE.min,FREQ_RANGE.max,DEG_RANGE.gridCnt); }

  for(const ds of distCharts.roll.data.datasets){ ds.hidden=true; ds.data.length=0; }
  for(const ds of distCharts.pitch.data.datasets){ ds.hidden=true; ds.data.length=0; }
  for(const ds of distCharts.freqRoll.data.datasets){ ds.hidden=true; ds.data.length=0; }
  for(const ds of distCharts.freqPitch.data.datasets){ ds.hidden=true; ds.data.length=0; }


  // Get current toggle states for AVG line/label
  let showAvgLine = true, showAvgLabel = false;
  const lineBox = document.getElementById('showAvgLine');
  const labelBox = document.getElementById('showAvgLabel');
  if (lineBox) showAvgLine = !!lineBox.checked;
  if (labelBox) showAvgLabel = !!labelBox.checked;

  // Remove all previous avg annotations from all distrib charts
  [distCharts.roll, distCharts.pitch, distCharts.freqRoll, distCharts.freqPitch].forEach(chart => {
    if (chart && chart.options.plugins && chart.options.plugins.annotation && chart.options.plugins.annotation.annotations) {
      Object.keys(chart.options.plugins.annotation.annotations).forEach(key => {
        if (key.startsWith('avgline_')) delete chart.options.plugins.annotation.annotations[key];
      });
    }
  });

  const rollK=getKdeFactorAngles(true);
  const pitchK=getKdeFactorAngles(false);
  const frqK=getKdeFactorFreq();

  // Gather all ys for roll, pitch, freq to determine max for each
  let allRollYs = [], allPitchYs = [], allFreqRollYs = [], allFreqPitchYs = [];
  const rollDatasets = [], pitchDatasets = [], freqRollDatasets = [], freqPitchDatasets = [];
  for(const id of Object.keys(units)){
    const u=units[id];
    const rI=upsertDistDataset(distCharts.roll, distIdx.roll, id, u.color);
    const pI=upsertDistDataset(distCharts.pitch,distIdx.pitch,id, u.color);
    const frI=upsertDistDataset(distCharts.freqRoll, distIdx.freqRoll = distIdx.freqRoll || {}, id, u.color);
    const fpI=upsertDistDataset(distCharts.freqPitch, distIdx.freqPitch = distIdx.freqPitch || {}, id, u.color);

    if(!u.visible || !u.times.length){
      distCharts.roll.data.datasets[rI].hidden=true;
      distCharts.pitch.data.datasets[pI].hidden=true;
      distCharts.freqRoll.data.datasets[frI].hidden=true;
      distCharts.freqPitch.data.datasets[fpI].hidden=true;
      continue;
    }

    const {tWin,rWin,pWin}=getWindowForUnit(u,winSec);

    if(rWin.length){
      let ys=kdeOnGridLogBackShift(rWin,distCharts.xsDeg,rollK);
      ys = ys.map(y=>y*100);
      allRollYs.push(...ys);
      rollDatasets.push({idx: rI, data: ys, color: u.color});
  // ...removed AVG line for live roll distrib...
    }
    if(pWin.length){
      let ys=kdeOnGridLogBackShift(pWin,distCharts.xsDeg,pitchK);
      ys = ys.map(y=>y*100);
      allPitchYs.push(...ys);
      pitchDatasets.push({idx: pI, data: ys, color: u.color});
  // ...removed AVG line for live pitch distrib...
    }
    // Roll freq
    const rPeaks=detectPeaks(rWin,tWin,parseFloat($('minDist').value||'300'),parseFloat($('minProm').value||'5.0'));
    const fSamplesR=freqSamplesFromPeaks(rPeaks);
    if(fSamplesR.length){
      let ys=kdeOnGridLogBack(fSamplesR,distCharts.xsHz,frqK);
      ys = ys.map(y=>y*100);
      allFreqRollYs.push(...ys);
      freqRollDatasets.push({idx: frI, data: ys, color: u.color});
  // ...removed AVG line for live freqRoll distrib...
    }
    // Pitch freq
    const pPeaks=detectPeaks(pWin,tWin,parseFloat($('minDist').value||'300'),parseFloat($('minProm').value||'5.0'));
    const fSamplesP=freqSamplesFromPeaks(pPeaks);
    if(fSamplesP.length){
      let ys=kdeOnGridLogBack(fSamplesP,distCharts.xsHz,frqK);
      ys = ys.map(y=>y*100);
      allFreqPitchYs.push(...ys);
      freqPitchDatasets.push({idx: fpI, data: ys, color: u.color});
  // ...removed AVG line for live freqPitch distrib...
    }
  }

  // Find y max for roll and pitch separately, then set both to the higher value
  const rollMax = Math.max(10, ...allRollYs);
  const pitchMax = Math.max(10, ...allPitchYs);
  const rollPitchMax = Math.max(rollMax, pitchMax) * 1.05;
  // Find y max for freq roll and pitch separately, then set both to the higher value
  const freqRollMax = Math.max(10, ...allFreqRollYs);
  const freqPitchMax = Math.max(10, ...allFreqPitchYs);
  const freqMax = Math.max(freqRollMax, freqPitchMax) * 1.05;
  distCharts.roll.options.scales.y.max = rollPitchMax;
  distCharts.pitch.options.scales.y.max = rollPitchMax;
  distCharts.freqRoll.options.scales.y.max = freqMax;
  distCharts.freqPitch.options.scales.y.max = freqMax;

  // Update datasets
  for(const ds of distCharts.roll.data.datasets){ ds.hidden=true; ds.data.length=0; }
  for(const ds of distCharts.pitch.data.datasets){ ds.hidden=true; ds.data.length=0; }
  for(const ds of distCharts.freqRoll.data.datasets){ ds.hidden=true; ds.data.length=0; }
  for(const ds of distCharts.freqPitch.data.datasets){ ds.hidden=true; ds.data.length=0; }
  for(const d of rollDatasets){
    const ds=distCharts.roll.data.datasets[d.idx];
    ds.data=points(distCharts.xsDeg,d.data);
    ds.borderColor=d.color; ds.backgroundColor=d.color+'22';
    // Set label to athlete custom name if available
    const unitId = Object.keys(distIdx.roll).find(key => distIdx.roll[key] === d.idx);
    ds.label = (unitId && units[unitId] && units[unitId].customName) ? units[unitId].customName : unitId || '';
    ds.hidden=false;
  }
  for(const d of pitchDatasets){
    const ds=distCharts.pitch.data.datasets[d.idx];
    ds.data=points(distCharts.xsDeg,d.data);
    ds.borderColor=d.color; ds.backgroundColor=d.color+'22';
    const unitId = Object.keys(distIdx.pitch).find(key => distIdx.pitch[key] === d.idx);
    ds.label = (unitId && units[unitId] && units[unitId].customName) ? units[unitId].customName : unitId || '';
    ds.hidden=false;
  }
  for(const d of freqRollDatasets){
    const ds=distCharts.freqRoll.data.datasets[d.idx];
    ds.data=points(distCharts.xsHz,d.data);
    ds.borderColor=d.color; ds.backgroundColor=d.color+'22';
    const unitId = Object.keys(distIdx.freqRoll).find(key => distIdx.freqRoll[key] === d.idx);
    ds.label = (unitId && units[unitId] && units[unitId].customName) ? units[unitId].customName : unitId || '';
    ds.hidden=false;
  }
  for(const d of freqPitchDatasets){
    const ds=distCharts.freqPitch.data.datasets[d.idx];
    ds.data=points(distCharts.xsHz,d.data);
    ds.borderColor=d.color; ds.backgroundColor=d.color+'22';
    const unitId = Object.keys(distIdx.freqPitch).find(key => distIdx.freqPitch[key] === d.idx);
    ds.label = (unitId && units[unitId] && units[unitId].customName) ? units[unitId].customName : unitId || '';
    ds.hidden=false;
  }

  distCharts.roll.update('none');
  distCharts.pitch.update('none');
  distCharts.freqRoll.update('none');
  distCharts.freqPitch.update('none');
}
function recomputePeaks(){
  const winSec=parseFloat(winNum.value||'30'), minDist=parseFloat($('minDist').value||'300'), minProm=parseFloat($('minProm').value||'5.0');

  for(const id of Object.keys(units)){
    const u=units[id]; if(!u.times.length) return;
    const {tWin,rWin,pWin,nowU,startMs}=getWindowForUnit(u,winSec);

    const rPeaks=detectPeaks(rWin,tWin,minDist,minProm);
    const pPeaks=detectPeaks(pWin,tWin,minDist,minProm);

    u.seriesRollPk.length=0; u.seriesPitchPk.length=0;
    for(const pk of rPeaks){u.seriesRollPk.push({x:(pk.t-globalT0)/1000,y:pk.v});}
    for(const pk of pPeaks){u.seriesPitchPk.push({x:(pk.t-globalT0)/1000,y:pk.v});}

    const freq=(peaks)=>{ if(peaks.length<2) return NaN; let s=0,c=0; for(let i=1;i<peaks.length;i++){const dt=(peaks[i].t-peaks[i-1].t)/1000; if(dt>0){s+=dt;c++;}} return c?1/(s/c):NaN; };
    const fR=freq(rPeaks), fP=freq(pPeaks);
    if(Number.isFinite(fR)){u.lastRollHz=fR;u.lastRollAt=nowU;}
    if(Number.isFinite(fP)){u.lastPitchHz=fP;u.lastPitchAt=nowU;}
    const fShowR=(Number.isFinite(u.lastRollHz)&&(nowU-(u.lastRollAt||0)<FREQ_HOLD_MS))?u.lastRollHz:(Number.isFinite(fR)?fR:NaN);
    const fShowP=(Number.isFinite(u.lastPitchHz)&&(nowU-(u.lastPitchAt||0)<FREQ_HOLD_MS))?u.lastPitchHz:(Number.isFinite(fP)?fP:NaN);

    const rs=meanStd(rWin), ps=meanStd(pWin);
    if(u.statsElems.rMean) u.statsElems.rMean.textContent=isFinite(rs.mean)?rs.mean.toFixed(2):'–';
    if(u.statsElems.rStd)  u.statsElems.rStd.textContent =isFinite(rs.std)? rs.std.toFixed(2) :'–';
    if(u.statsElems.pMean) u.statsElems.pMean.textContent=isFinite(ps.mean)?ps.mean.toFixed(2):'–';
    if(u.statsElems.pStd)  u.statsElems.pStd.textContent =isFinite(ps.std)? ps.std.toFixed(2) :'–';
    // Mean SOG (window)
    let sIdx=0; while(sIdx<u.sogTimes.length && u.sogTimes[sIdx]<startMs) sIdx++;
    const sogWin=u.sogVals.slice(sIdx);
    const sogStats=meanStd(sogWin);
    if(u.nowElems.sogMean)   u.nowElems.sogMean.textContent  =isFinite(sogStats.mean)?sogStats.mean.toFixed(2):'–';

    const fNow = Number.isFinite(fShowR)?fShowR:(Number.isFinite(fShowP)?fShowP:NaN);
    if(u.nowElems.hz) u.nowElems.hz.textContent = isFinite(fNow)? fNow.toFixed(2):'–';
  }

  updateUnifiedDistributions();
}

// ---------- receiver clock-based plotting ----------
let plotTimer = null;
let livePlottingEnabled = true;
let lastPlotT = 0;
function startPlotTimer() {
  if (plotTimer) clearInterval(plotTimer);
  if (!livePlottingEnabled || stayAwakeMode) return;
  plotTimer = setInterval(() => {
    if (stayAwakeMode) return; // Don't update plots in stay awake mode
    const now = Date.now();
    if (globalT0 === null) {
      // Set globalT0 to the earliest data point across all units
      let t0 = null;
      for (const id of Object.keys(units)) {
        if (units[id].times.length) {
          const t = units[id].times[0];
          if (t0 === null || t < t0) t0 = t;
        }
      }
      if (t0 !== null) globalT0 = t0;
      else return;
    }
    const tPlot = now;
    const x = (tPlot - globalT0) / 1000;
    for (const id of Object.keys(units)) {
      const u = units[id];
      // Find the latest sample for this unit
      let yR = null, yP = null;
      if (u.times.length) {
        // Only use data if it arrived since last plot tick
        const lastT = u.times[u.times.length - 1];
        if (!u._lastPlottedT || lastT > u._lastPlottedT) {
          yR = u.roll[u.roll.length - 1];
          yP = u.pitch[u.pitch.length - 1];
          u._lastPlottedT = lastT;
        }
      }
      // If new data, append; if not, append a gap (null)
      if (yR !== null) {
        u.seriesRoll.push({ x, y: yR });
      } else {
        u.seriesRoll.push({ x, y: null });
      }
      if (yP !== null) {
        u.seriesPitch.push({ x, y: yP });
      } else {
        u.seriesPitch.push({ x, y: null });
      }
    }
    pruneOld(tPlot);
    recomputePeaks();
    updateAxisRange();
    chartTS.update('none');
    chartSOG.update('none');
    lastPlotT = tPlot;
  }, 100); // 10Hz
}
startPlotTimer();
// Live plotting toggle button logic
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('btnToggleLivePlot');
  if (!btn) return;
  btn.onclick = function() {
    livePlottingEnabled = !livePlottingEnabled;
    if (plotTimer) clearInterval(plotTimer);
    if (livePlottingEnabled) {
      btn.textContent = 'Pause Live Plotting';
      startPlotTimer();
    } else {
      btn.textContent = 'Resume Live Plotting';
    }
  };
});

// ---------- velocity, distances & VMG ----------
const Rm=6371000;
function projLocalMeters(lat0,lon0,lat,lon){const toR=a=>a*Math.PI/180;return {x:(toR(lon)-toR(lon0))*Math.cos(toR(lat0))*Rm,y:(toR(lat)-toR(lat0))*Rm}}
function bearingFromV(vx,vy){ const toD=a=>a*180/Math.PI; let brg=toD(Math.atan2(vx,vy)); if(brg<0) brg+=360; return brg; }
const KNOTS_PER_MPS=1.94384449;

// compute orthogonal distance (absolute) from point P to infinite line AB in meters
function orthogonalDistanceToLine(ax,ay,bx,by,px,py){
  const vx=bx-ax, vy=by-ay;
  const wx=px-ax, wy=py-ay;
  const vlen=Math.hypot(vx,vy);
  if(vlen<=0) return Math.hypot(wx,wy);
  const cross = Math.abs(vx*wy - vy*wx);
  return cross / vlen;
}

function updateDistancesForUnit(u, pxy, lat, lon){
  // Dist -> top
  if(topMark){
    const tm = projLocalMeters(u.lat0,u.lon0, topMark.lat, topMark.lon);
    const rx = tm.x - pxy.x, ry = tm.y - pxy.y;
    const dTop = Math.hypot(rx,ry);
    if(u.nowElems.dTop) u.nowElems.dTop.textContent = Number.isFinite(dTop)? dTop.toFixed(1) : '–';
  } else {
    if(u.nowElems.dTop) u.nowElems.dTop.textContent = '–';
  }
  // Dist -> start line (orthogonal to infinite line)
  if(startLine){
    const A = projLocalMeters(u.lat0,u.lon0, startLine.a.lat, startLine.a.lon);
    const B = projLocalMeters(u.lat0,u.lon0, startLine.b.lat, startLine.b.lon);
    const dStart = orthogonalDistanceToLine(A.x,A.y,B.x,B.y,pxy.x,pxy.y);
    if(u.nowElems.dStart) u.nowElems.dStart.textContent = Number.isFinite(dStart)? dStart.toFixed(1) : '–';
  } else {
    if(u.nowElems.dStart) u.nowElems.dStart.textContent = '–';
  }
}

function updateVelocityFromWindow(u,t,lat,lon){
  if(u.lat0===null||u.lon0===null){ u.lat0=lat; u.lon0=lon; }

  const p=projLocalMeters(u.lat0,u.lon0,lat,lon);
  u.posBuf.push({t,lat,lon,x:p.x,y:p.y});
  const winMs=getSogWinSec()*1000;
  while(u.posBuf.length && u.posBuf[0].t < t - winMs){ u.posBuf.shift(); }
  if(u.posBuf.length<2) return;

  const times=u.posBuf.map(pt=>(pt.t-u.posBuf[0].t)/1000);
  const xs=u.posBuf.map(pt=>pt.x), ys=u.posBuf.map(pt=>pt.y);
  const n=times.length;
  let mt=0,mx=0,my=0; for(let i=0;i<n;i++){ mt+=times[i]; mx+=xs[i]; my+=ys[i]; }
  mt/=n; mx/=n; my/=n;
  let sTT=0,sTX=0,sTY=0;
  for(let i=0;i<n;i++){ const dt=times[i]-mt; sTT+=dt*dt; sTX+=dt*(xs[i]-mx); sTY+=dt*(ys[i]-my); }
  if(sTT<=0) return;
  const vx=sTX/sTT, vy=sTY/sTT;
  u.vx=vx; u.vy=vy;

  const spd_mps=Math.hypot(vx,vy), spd_kt=spd_mps*KNOTS_PER_MPS;

  const alpha=0.2;
  u.sogEMA=(u.sogEMA==null)?spd_kt:(u.sogEMA*(1-alpha)+spd_kt*alpha);
  u.heading=(u.sogEMA>2)?bearingFromV(vx,vy):null;

  const xPlot=(t-globalT0)/1000;
  u.sogTimes.push(t); u.sogVals.push(u.sogEMA); u.sogSeries.push({x:xPlot,y:u.sogEMA});

  // VMG toward top mark (if set)
  if(topMark){
    const m = projLocalMeters(u.lat0,u.lon0, topMark.lat, topMark.lon);
    const rx = m.x - p.x, ry = m.y - p.y;
    const rmag = Math.hypot(rx,ry);
    let vmg_kt = 0;
    if(rmag>0){
      const vmg_mps = (vx*rx + vy*ry) / rmag;
      vmg_kt = vmg_mps * KNOTS_PER_MPS;
    }
    if(Number.isFinite(vmg_kt)){
      u.vmgTimes.push(t); u.vmgVals.push(vmg_kt); u.vmgSeries.push({x:xPlot,y:vmg_kt});
      if(u.nowElems.vmg) u.nowElems.vmg.textContent = vmg_kt.toFixed(2);
    }
  } else {
    if(u.nowElems.vmg) u.nowElems.vmg.textContent = '–';
  }

  // distances
  updateDistancesForUnit(u, p, lat, lon);
}

// ---------- Top Mark placement ----------
function clearVMGSeriesAll(){
  for(const id of Object.keys(units)){
    const u=units[id];
    u.vmgTimes.length=0; u.vmgVals.length=0; u.vmgSeries.length=0;
    if(u.nowElems.vmg) u.nowElems.vmg.textContent = '–';
  }
  chartSOG.update('none');
}
function setTopMark(lat,lon){
  topMark = {lat,lon};
  const accent = cssVar('--accent','#ffcc00');
  window._topMarkCoords = {lat, lon};
  if(topMarkLayer){
    topMarkLayer.setLatLng([lat,lon]);
    topMarkLayer.setStyle({color:accent, fillColor:accent});
  }else{
    topMarkLayer = L.circleMarker([lat,lon],{radius:8,color:accent,fillColor:accent,fillOpacity:1,weight:3}).addTo(map);
  }
  $('topMarkInfo').textContent = `Top mark: ${lat.toFixed(6)}, ${lon.toFixed(6)} — click "Replace Top Mark" to change.`;
  const btn=$('btnTopMark'); if(btn) btn.textContent='Replace Top Mark';
  clearVMGSeriesAll(); // VMG target changed
  log(`Top mark set at ${lat.toFixed(6)}, ${lon.toFixed(6)}`);
}
function startPlaceTopMark(){
  if(!mapInited){ log('map not ready'); return; }
  // Do NOT switch tab
  const msg=$('sogInfo'); if(msg) msg.textContent='Click on the map to set Top Mark…';
  map.once('click', (e)=>{
    setTopMark(e.latlng.lat, e.latlng.lng);
    if(msg) msg.textContent='';
  });
}

// ---------- Start Line placement (two clicks, show first point immediately) ----------
function setStartLine(aLat,aLon,bLat,bLon){
  startLine = { a:{lat:aLat,lon:aLon}, b:{lat:bLat,lon:bLon} };
  window._startLineCoords = {a:{lat:aLat,lon:aLon}, b:{lat:bLat,lon:bLon}};
  const accent = cssVar('--accent','#ffcc00');

  if(startLineLayer){
    startLineLayer.setLatLngs([[aLat,aLon],[bLat,bLon]]);
    startLineLayer.setStyle({color:accent,weight:3,opacity:0.9});
  }else{
    startLineLayer = L.polyline([[aLat,aLon],[bLat,bLon]],{color:accent,weight:3,opacity:0.9}).addTo(map);
  }

  if(!startLineMarkers.a){
    startLineMarkers.a = L.circleMarker([aLat,aLon],{radius:6,color:accent,fillColor:accent,fillOpacity:1}).addTo(map);
  } else {
    startLineMarkers.a.setLatLng([aLat,aLon]).setStyle({color:accent,fillColor:accent});
  }
  if(!startLineMarkers.b){
    startLineMarkers.b = L.circleMarker([bLat,bLon],{radius:6,color:accent,fillColor:accent,fillOpacity:1}).addTo(map);
  } else {
    startLineMarkers.b.setLatLng([bLat,bLon]).setStyle({color:accent,fillColor:accent});
  }

  $('startLineInfo').textContent = `Start line: A ${aLat.toFixed(6)},${aLon.toFixed(6)} — B ${bLat.toFixed(6)},${bLon.toFixed(6)} (Replace Start Line to change).`;
  const btn=$('btnStartLine'); if(btn) btn.textContent='Replace Start Line';
  log('Start line set.');
}

function startPlaceStartLine(){
  if(!mapInited){ log('map not ready'); return; }
  // Do NOT switch tab
  placingStartPhase = 1;
  $('sogInfo').textContent = 'Click on the map to set start line point A…';
  let A = null;

  const accent = cssVar('--accent','#ffcc00');

  const clickA = (e)=>{
    A = e.latlng;
    // Show first point immediately
    if(!startLineMarkers.a){
      startLineMarkers.a = L.circleMarker([A.lat,A.lng],{radius:6,color:accent,fillColor:accent,fillOpacity:1}).addTo(map);
    } else {
      startLineMarkers.a.setLatLng([A.lat,A.lng]).setStyle({color:accent,fillColor:accent});
    }
    // If there was a previous B marker but no line, hide it for now
    if(startLineMarkers.b && !startLineLayer){
      startLineMarkers.b.setStyle({opacity:0, fillOpacity:0});
    }
    $('sogInfo').textContent = 'Click on the map to set start line point B…';
    placingStartPhase = 2;
    map.once('click', clickB);
  };
  const clickB = (e)=>{

    const B = e.latlng;
    // Reveal/update B marker immediately too
    if(!startLineMarkers.b){
      startLineMarkers.b = L.circleMarker([B.lat,B.lng],{radius:6,color:accent,fillColor:accent,fillOpacity:1}).addTo(map);
    } else {
      startLineMarkers.b.setLatLng([B.lat,B.lng]).setStyle({color:accent,fillColor:accent,opacity:1,fillOpacity:1});
    }
    setStartLine(A.lat,A.lng,B.lat,B.lng);
    $('sogInfo').textContent = '';
    placingStartPhase = 0;
  };

  map.once('click', clickA);
}

// ---------- Recording & Reports ----------
const btnRecord=$('btnRecord'), recInfo=$('recInfo');
btnRecord.addEventListener('click',()=>{ if(!recActive){ startRec(); } else { stopRec(); } });

// Store all recordings in session and persist to localStorage until deleted
let allRecordings = [];
const RECORDINGS_KEY = 'recordings_all';

function saveRecordingsToStorage() {
  try {
    localStorage.setItem(RECORDINGS_KEY, JSON.stringify(allRecordings));
  } catch (e) { console.warn('Failed to save recordings:', e); }
}

function loadRecordingsFromStorage() {
  try {
    const data = localStorage.getItem(RECORDINGS_KEY);
    if (data) {
      allRecordings = JSON.parse(data);
      generateReportsTabs();
    }
  } catch (e) { console.warn('Failed to load recordings:', e); }
}

// Load on startup
window.addEventListener('DOMContentLoaded', loadRecordingsFromStorage);

// Show all cached athlete names as editable config rows in settings
function renderAllUnitConfigRows() {
  const container = document.getElementById('unitsConfig');
  if (!container) return;
  container.innerHTML = '';
  const config = loadUnitConfig();
  const allUnitIds = Object.keys(config);
  if (allUnitIds.length === 0) {
    const msg = document.createElement('div');
    msg.className = 'small';
    msg.textContent = 'No cached athlete names.';
    container.appendChild(msg);
    return;
  }
  allUnitIds.forEach(unitId => {
    let row = document.createElement('div');
    row.className = 'unit-config-row';
    row.dataset.unit = unitId;
    row.style.display = 'grid';
    row.style.gridTemplateColumns = 'minmax(80px, 1fr) minmax(120px, 1.5fr) minmax(100px, 1fr)';
    row.style.gap = '8px';
    row.style.alignItems = 'center';

    // Original name label
    const origLabel = document.createElement('div');
    origLabel.className = 'small';
    origLabel.textContent = unitId;
    row.appendChild(origLabel);

    // Custom name input
    const nameInput = document.createElement('input');
    nameInput.className = 'unit-custom-name';
    nameInput.type = 'text';
    nameInput.placeholder = 'Custom name';
    nameInput.value = config[unitId].customName || '';
    row.appendChild(nameInput);

    // Color select
    const colorSelect = document.createElement('select');
    colorSelect.className = 'unit-color';
    COLORS_PALETTE.forEach(color => {
      const opt = document.createElement('option');
      opt.value = color.value;
      opt.textContent = color.name;
      if (color.value === (config[unitId].color || COLORS_BASE[0])) {
        opt.selected = true;
      }
      colorSelect.appendChild(opt);
    });
    row.appendChild(colorSelect);

    container.appendChild(row);
  });
}
document.addEventListener('DOMContentLoaded', renderAllUnitConfigRows);
window.addEventListener('storage', renderAllUnitConfigRows);
// Also call after saving config (add to your config save logic if needed)

function startRec(){
  recActive=true; recRows=[]; recStartedAt=Date.now();
  btnRecord.textContent="Stop & Save"; btnRecord.classList.add('recording','blink');
  if(window._rt) clearInterval(window._rt);
  window._rt=setInterval(()=>{recInfo.textContent=`Recording… ${((Date.now()-recStartedAt)/1000).toFixed(1)} s`;},200);
  log("recording started");
}

function stopRec(){
  recActive=false; btnRecord.textContent="Start Recording"; btnRecord.classList.remove('recording','blink');
  if(window._rt){clearInterval(window._rt);window._rt=null;}
  if(!recRows.length){recInfo.textContent="No samples recorded.";log("no samples to save");return;}

  // Save recording data for reports
  const recording = {
    id: 'rec-' + (allRecordings.length+1),
    startedAt: recStartedAt,
    rows: recRows.slice(),
    topMark: window._topMarkCoords ? {...window._topMarkCoords} : null,
    startLine: window._startLineCoords ? {...window._startLineCoords} : null
  };
  allRecordings.push(recording);
  saveRecordingsToStorage();
  generateReportsTabs();

  // CSV download with athlete names
  const header=['unit_id','athlete','timestamp_ms','iso_time','elapsed_s','seq','roll_deg','pitch_deg','lat','lon','gnss_ms','gnss_iso'];
  const lines=[header.join(',')];
  let topMarkLine = 'top_mark', startPt1Line = 'start_pt1', startPt2Line = 'start_pt2';
  if(window._topMarkCoords && typeof window._topMarkCoords.lat === 'number' && typeof window._topMarkCoords.lon === 'number') {
    topMarkLine += `,${window._topMarkCoords.lat.toFixed(6)},${window._topMarkCoords.lon.toFixed(6)}`;
  } else {
    topMarkLine += ',,';
  }
  if(window._startLineCoords && window._startLineCoords.a && window._startLineCoords.b) {
    startPt1Line += `,${window._startLineCoords.a.lat.toFixed(6)},${window._startLineCoords.a.lon.toFixed(6)}`;
    startPt2Line += `,${window._startLineCoords.b.lat.toFixed(6)},${window._startLineCoords.b.lon.toFixed(6)}`;
  } else {
    startPt1Line += ',,';
    startPt2Line += ',,';
  }
  lines.push(topMarkLine);
  lines.push(startPt1Line);
  lines.push(startPt2Line);
  for(const r of recRows){
    const iso=new Date(r.t).toISOString();
    const u = units[r.unit];
    const athlete = u ? u.customName || r.unit : r.unit;
    lines.push([r.unit,athlete,r.t,`"${iso.replace(/"/g,'""')}"`,
                (globalT0!==null?((r.t-globalT0)/1000).toFixed(3):''),
                (r.seq??''),r.roll.toFixed(6),r.pitch.toFixed(6),
                (Number.isFinite(r.lat)?r.lat.toFixed(6):''),(Number.isFinite(r.lon)?r.lon.toFixed(6):''),
                (r.gnss_ms??''), r.gnss_iso?`"${r.gnss_iso}"`:''].join(','));
  }
  const csv=lines.join('\n'), blob=new Blob([csv],{type:'text/csv'}), d=new Date(recStartedAt||Date.now());
  const fname=`trollsports_multi_${d.getFullYear()}-${fmt2(d.getMonth()+1)}-${fmt2(d.getDate())}_${fmt2(d.getHours())}-${fmt2(d.getMinutes())}-${fmt2(d.getSeconds())}.csv`;
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=fname; document.body.appendChild(a); a.click();
  setTimeout(()=>{URL.revokeObjectURL(a.href);a.remove();},1000);
  recInfo.textContent=`Saved ${recRows.length} samples to ${fname}`; log(`saved CSV (${recRows.length} rows)`);
}

// Generate Reports tab subtabs and content
function generateReportsTabs() {
  const tabsEl = document.getElementById('reportsTabs');
  const contentEl = document.getElementById('reportsContent');
  if (!tabsEl || !contentEl) return;
  tabsEl.innerHTML = '';
  contentEl.innerHTML = '';
  if (allRecordings.length === 0) {
    contentEl.innerHTML = '<div class="small">No recordings yet. Finish a recording to see reports.</div>';
    return;
  }
  allRecordings.forEach((rec, idx) => {
    const btn = document.createElement('button');
    btn.className = 'tabbtn' + (idx === allRecordings.length-1 ? ' active' : '');
    // Use custom label if set, else format start time as HH:MM:SS
    let label = rec.label && rec.label.trim() ? rec.label : `Recording ${idx+1}`;
    if (!rec.label && rec.startedAt) {
      const d = new Date(rec.startedAt);
      if (!isNaN(d.getTime())) {
        const h = String(d.getHours()).padStart(2, '0');
        const m = String(d.getMinutes()).padStart(2, '0');
        const s = String(d.getSeconds()).padStart(2, '0');
        label = `${h}:${m}:${s}`;
      }
    }
    btn.textContent = label;
    btn.dataset.recId = rec.id;
    btn.onclick = () => showReportFor(rec.id);
    tabsEl.appendChild(btn);
  });
  // Add delete button
  const delBtn = document.createElement('button');
  delBtn.textContent = 'Delete Selected Report';
  delBtn.className = 'small';
  delBtn.style.marginLeft = '16px';
  delBtn.onclick = function() {
    const activeBtn = tabsEl.querySelector('.tabbtn.active');
    if (!activeBtn) return;
    const recId = activeBtn.dataset.recId;
    const idx = allRecordings.findIndex(r => r.id === recId);
    if (idx !== -1) {
      if (confirm('Delete this report?')) {
        allRecordings.splice(idx, 1);
        saveRecordingsToStorage();
        generateReportsTabs();
      }
    }
  };
  tabsEl.appendChild(delBtn);

  // Add rename button
  const renBtn = document.createElement('button');
  renBtn.textContent = 'Rename Selected Report';
  renBtn.className = 'small';
  renBtn.style.marginLeft = '8px';
  renBtn.onclick = function() {
    const activeBtn = tabsEl.querySelector('.tabbtn.active');
    if (!activeBtn) return;
    const recId = activeBtn.dataset.recId;
    const rec = allRecordings.find(r => r.id === recId);
    if (rec) {
      const newName = prompt('Enter new name for this report:', rec.label || '');
      if (newName && newName.trim()) {
        rec.label = newName.trim();
        saveRecordingsToStorage();
        generateReportsTabs();
      }
    }
  };
  tabsEl.appendChild(renBtn);
  // Show latest by default
  showReportFor(allRecordings[allRecordings.length-1].id);
}

function showReportFor(recId) {
  const rec = allRecordings.find(r => r.id === recId);
  if (!rec) return;
  // Highlight active subtab
  document.querySelectorAll('#reportsTabs .tabbtn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.recId === recId);
  });
  // Show stats and a box with roll/pitch distribs
  const stats = computeRecordingStats(rec.rows);
  const started = new Date(rec.startedAt);
  // Athlete show/hide controls
  // Group by unit
  const byUnit = {};
  rec.rows.forEach(r => {
    if (!byUnit[r.unit]) byUnit[r.unit] = [];
    byUnit[r.unit].push(r);
  });
  const unitIds = Object.keys(byUnit);
  // Get unit colors from localStorage
  window.unitSettings = JSON.parse(localStorage.getItem('unitColors') || '{}');
  const colorMap = {};
  unitIds.forEach(id => { 
    const storedUnit = window.unitSettings[id] || {};
    colorMap[id] = storedUnit.color || COLORS_BASE[0];
  });
  // Show/hide state (persisted per report in-memory)
  if (!rec._athleteShow) rec._athleteShow = {};
  unitIds.forEach(id => { if (rec._athleteShow[id] === undefined) rec._athleteShow[id] = true; });
  let html = `<div class="small" style="margin-bottom:16px;">Recording started: ${started.toLocaleString()}<br>Samples: ${rec.rows.length}</div>`;
  // Athlete show/hide buttons above stats
  html += `<div class="card" style="margin-bottom:16px;padding:12px 16px 8px 16px;max-width:600px;">
    <div style="font-weight:700;margin-bottom:8px;">Show/hide athletes:</div>
    <div id="report-athlete-show" style="display:flex;gap:12px;flex-wrap:wrap;">`;
  unitIds.forEach(id => {
    const color = colorMap[id];
    html += `<button class="small" data-athlete="${id}" style="background:${rec._athleteShow[id] ? color : '#eee'};color:${rec._athleteShow[id] ? '#fff':'#333'};border-radius:6px;padding:2px 10px 2px 10px;min-width:60px;cursor:pointer;">${rec._athleteShow[id] ? 'Hide' : 'Show'} ${window.unitSettings[id]?.name || id}</button>`;
  });
  html += `</div></div>`;
  // Stats tiles, one per athlete, only if shown
  html += `<div id="report-athlete-stats" style="display:flex;gap:12px;flex-wrap:wrap;margin-bottom:16px;">`;
  // Helper: calculate distance (meters) and bearing (degrees) between two lat/lon points
  function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000; // meters
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
      Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }
  function bearing(lat1, lon1, lat2, lon2) {
    const toRad = x => x * Math.PI / 180;
    const toDeg = x => x * 180 / Math.PI;
    const dLon = toRad(lon2 - lon1);
    const y = Math.sin(dLon) * Math.cos(toRad(lat2));
    const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
      Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
    let brng = Math.atan2(y, x);
    brng = toDeg(brng);
    return (brng + 360) % 360;
  }

  unitIds.forEach(id => {
    if (!rec._athleteShow[id]) return;
    // Compute stats for this athlete
    const arr = byUnit[id] || [];
    const rolls = arr.map(r => r.roll).filter(Number.isFinite);
    const pitchs = arr.map(r => r.pitch).filter(Number.isFinite);

    // Calculate SOG and heading from lat/lon and t
    const sogs = [];
    const headings = [];
    for (let i = 1; i < arr.length; ++i) {
      const r1 = arr[i-1], r2 = arr[i];
      if (Number.isFinite(r1.lat) && Number.isFinite(r1.lon) && Number.isFinite(r2.lat) && Number.isFinite(r2.lon) && Number.isFinite(r1.t) && Number.isFinite(r2.t)) {
        const dt = (r2.t - r1.t) / 1000; // seconds
        if (dt > 0 && dt < 30) { // skip huge jumps
          const dist = haversine(r1.lat, r1.lon, r2.lat, r2.lon); // meters
          sogs.push(dist / dt / 0.514444); // convert m/s to knots
          headings.push(bearing(r1.lat, r1.lon, r2.lat, r2.lon));
        }
      }
    }

    // Mean and SD helpers
    function meanStd(a) {
      if (!a.length) return {mean: null, sd: null, max: null};
      const mean = a.reduce((s,v)=>s+v,0)/a.length;
      const sd = Math.sqrt(a.reduce((s,v)=>s+(v-mean)*(v-mean),0)/a.length);
      const max = Math.max(...a);
      return {mean, sd, max};
    }
    const rollStats = meanStd(rolls);
    const pitchStats = meanStd(pitchs);
    const sogStats = meanStd(sogs);
    const headingStats = meanStd(headings);
    html += `<div class="card half unitStats" style="--ucolor:${colorMap[id]};min-width:200px;">
  <div style="font-weight:700;margin-bottom:8px;"><span class="unitTag" style="background:${colorMap[id]}">${window.unitSettings[id]?.name || id}</span></div>
      <div class="grid">
        <div><div class="small">Roll (°)</div><div class="num">${rollStats.mean!==null ? rollStats.mean.toFixed(2)+' ±'+rollStats.sd.toFixed(2)+'°' : '–'}</div></div>
        <div><div class="small">Pitch (°)</div><div class="num">${pitchStats.mean!==null ? pitchStats.mean.toFixed(2)+' ±'+pitchStats.sd.toFixed(2)+'°' : '–'}</div></div>
        <div><div class="small">SOG (kt)</div><div class="num">${sogStats.mean!==null ? sogStats.mean.toFixed(2)+' ±'+sogStats.sd.toFixed(2) : '–'}</div></div>
        <div><div class="small">Max SOG (kt)</div><div class="num">${sogStats.max!==null ? sogStats.max.toFixed(2) : '–'}</div></div>
        <div><div class="small">Heading (°)</div><div class="num">${headingStats.mean!==null ? headingStats.mean.toFixed(1)+' ±'+headingStats.sd.toFixed(1)+'°' : '–'}</div></div>
      </div>
    </div>`;
  });
  html += `</div>`;
  const plotW = 900, plotH = 280;
  html += `
  <div class="reports-tiles-grid">
      <div class="card grow" style="padding:24px 20px;display:flex;flex-direction:column;gap:12px;min-height:${plotH+60}px;">
        <div style='font-weight:700;margin-bottom:4px;text-align:center;'>Roll Distribution</div>
        <div class="plot"><canvas id="report-kde-roll" width="${plotW}" height="${plotH}" style="width:100%;height:100%;max-width:100%;max-height:100%;"></canvas></div>
      </div>
      <div class="card grow" style="padding:24px 20px;display:flex;flex-direction:column;gap:12px;min-height:${plotH+60}px;">
        <div style='font-weight:700;margin-bottom:4px;text-align:center;'>Pitch Distribution</div>
        <div class="plot"><canvas id="report-kde-pitch" width="${plotW}" height="${plotH}" style="width:100%;height:100%;max-width:100%;max-height:100%;"></canvas></div>
      </div>
      <div class="card grow" style="padding:24px 20px;display:flex;flex-direction:column;gap:12px;min-height:${plotH+60}px;">
        <div style='font-weight:700;margin-bottom:4px;text-align:center;'>Roll Frequency Distribution</div>
        <div class="plot"><canvas id="report-kde-freq-roll" width="${plotW}" height="${plotH}" style="width:100%;height:100%;max-width:100%;max-height:100%;"></canvas></div>
      </div>
      <div class="card grow" style="padding:24px 20px;display:flex;flex-direction:column;gap:12px;min-height:${plotH+60}px;">
        <div style='font-weight:700;margin-bottom:4px;text-align:center;'>Pitch Frequency Distribution</div>
        <div class="plot"><canvas id="report-kde-freq-pitch" width="${plotW}" height="${plotH}" style="width:100%;height:100%;max-width:100%;max-height:100%;"></canvas></div>
      </div>
    </div>
    <div class="card grow" style="padding:24px 20px;display:flex;flex-direction:column;gap:12px;min-width:320px;margin-top:32px;">
      <div style='font-weight:700;margin-bottom:4px;text-align:center;'>Polar Plot: Heading (°) vs SOG (kt)</div>
      <div class="plot" style="height:340px;min-height:240px;"><canvas id="report-polar-heading-sog" width="500" height="320" style="width:100%;height:100%;max-width:100%;max-height:100%;"></canvas></div>
      
    </div>
  `;
  document.getElementById('reportsContent').innerHTML = html;
  // Draw the distribs and handle show/hide
  setTimeout(() => {
  // Only include shown athletes
  const shownIds = unitIds.filter(id => rec._athleteShow[id]);
  // Group by unit, filtered
  const byUnit = {};
  rec.rows.forEach(r => {
    if (shownIds.includes(r.unit)) {
      if (!byUnit[r.unit]) byUnit[r.unit] = [];
      byUnit[r.unit].push(r);
    }
  });
    // --- Radar chart: Heading bins vs mean SOG ---
    // Bin headings into 12 sectors (30° each)
  const headingBins = Array.from({length: 12}, (_, i) => i * 30);
  // Only label 0, 90, 180, 270 degrees
  const headingLabels = headingBins.map(d => ([0,90,180,270].includes(d) ? `${d}°` : ''));
    const radarDatasets = shownIds.map(unit => {
      const arr = byUnit[unit] || [];
      // Calculate heading and SOG for each segment
      const sogs = [];
      const headings = [];
      for (let i = 1; i < arr.length; ++i) {
        const r1 = arr[i-1], r2 = arr[i];
        if (Number.isFinite(r1.lat) && Number.isFinite(r1.lon) && Number.isFinite(r2.lat) && Number.isFinite(r2.lon) && Number.isFinite(r1.t) && Number.isFinite(r2.t)) {
          const dt = (r2.t - r1.t) / 1000;
          if (dt > 0 && dt < 30) {
            const dist = haversine(r1.lat, r1.lon, r2.lat, r2.lon);
            sogs.push(dist / dt / 0.514444);
            headings.push(bearing(r1.lat, r1.lon, r2.lat, r2.lon));
          }
        }
      }
      // Bin SOG by heading
      const binSums = Array(12).fill(0);
      const binCounts = Array(12).fill(0);
      headings.forEach((h, i) => {
        const bin = Math.floor(h / 30) % 12;
        binSums[bin] += sogs[i];
        binCounts[bin]++;
      });
      const binMeans = binSums.map((sum, i) => binCounts[i] ? sum / binCounts[i] : 0);
      const storedUnit = window.unitSettings?.[unit] || {};
      return {
        label: storedUnit.customName || unit,
        data: binMeans,
        borderColor: colorMap[unit] || COLORS_BASE[0],
        backgroundColor: (colorMap[unit] || COLORS_BASE[0]) + '33',
        pointRadius: 3,
        fill: true,
        tension: 0.2
      };
    });
    // Compute adaptive SOG max for radar chart
    let maxSog = 2;
    radarDatasets.forEach(ds => {
      const dsMax = Math.max(...ds.data);
      if (dsMax > maxSog) maxSog = dsMax;
    });
    // Round up to next even number for nice ticks
    maxSog = Math.ceil(maxSog / 2) * 2;
    // Compute SOG tick values for max 5 labels
    let sogTicks = [0, maxSog];
    if (maxSog > 0) {
      const nTicks = Math.min(5, Math.floor(maxSog / 2) + 1);
      sogTicks = Array.from({length: nTicks}, (_, i) => Math.round(i * maxSog / (nTicks - 1)));
    }
    // Draw radar chart
    const polarEl = document.getElementById('report-polar-heading-sog');
    if (polarEl) {
      if (polarEl._chartjs) { polarEl._chartjs.destroy(); }
      let datasetsToShow = radarDatasets;
      // If no data, show a single empty dataset (transparent)
      if (!radarDatasets.some(ds => ds.data.some(v => v > 0))) {
        datasetsToShow = [{
          label: '',
          data: Array(12).fill(0),
          borderColor: 'rgba(0,0,0,0.08)',
          backgroundColor: 'rgba(0,0,0,0.03)',
          pointRadius: 0,
          fill: true,
          tension: 0.2
        }];
      }
      polarEl._chartjs = new Chart(polarEl.getContext('2d'), {
        type: 'radar',
        data: { labels: headingLabels, datasets: datasetsToShow },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: {
            legend: { display: radarDatasets.some(ds => ds.data.some(v => v > 0)), position: 'bottom', labels: { boxWidth: 10, boxHeight: 10, usePointStyle: true, pointStyle: 'line', color: '#000' } },
            tooltip: { enabled: radarDatasets.some(ds => ds.data.some(v => v > 0)), callbacks: { label: ctx => `${ctx.dataset.label}: ${ctx.formattedValue} kt @ ${ctx.label}` } }
          },
          scales: {
            r: {
              min: 0,
              max: maxSog,
              angleLines: { color: '#e0e0e0' },
              grid: { color: '#e0e0e0' },
              pointLabels: { color: '#000', font: { size: 12 } },
              ticks: {
                color: '#000',
                callback: v => sogTicks.includes(v) ? v : '',
                maxTicksLimit: 5,
                stepSize: undefined
              }
            }
          },
          aspectRatio: 1
        }
      });
    }
    // Only include shown athletes
    // Group by unit, filtered
  // (byUnit already declared and populated above)
    // Prepare KDE data for all shown units
    const kdeData = { roll: {}, pitch: {}, freqRoll: {}, freqPitch: {} };
    shownIds.forEach(unit => {
      const arr = byUnit[unit] || [];
      const rolls = arr.map(r => r.roll).filter(Number.isFinite);
      const pitchs = arr.map(r => r.pitch).filter(Number.isFinite);
      const times = arr.map(r => r.t).filter(Number.isFinite);
      kdeData.roll[unit] = { data: rolls };
      kdeData.pitch[unit] = { data: pitchs };
      // Use detectPeaks and freqSamplesFromPeaks as in live
      const minDist = 300, minProm = 5.0;
      const rPeaks = detectPeaks(rolls, times, minDist, minProm);
      const pPeaks = detectPeaks(pitchs, times, minDist, minProm);
      kdeData.freqRoll[unit] = { data: freqSamplesFromPeaks(rPeaks) };
      kdeData.freqPitch[unit] = { data: freqSamplesFromPeaks(pPeaks) };
    });
    // Compute y max for roll/pitch and freq using KDE smoothing and scaling by 100
    const xsRoll = linspace(DEG_RANGE.min, DEG_RANGE.max, DEG_RANGE.gridCnt);
    const xsFreq = linspace(FREQ_RANGE.min, FREQ_RANGE.max, FREQ_RANGE.gridCnt);
    let rollMax = 0, pitchMax = 0, freqRollMax = 0, freqPitchMax = 0;
    Object.entries(kdeData.roll).forEach(([unit, d]) => {
      if (d.data && d.data.length) {
        const ys = kdeOnGridLogBackShift(d.data, xsRoll, getKdeFactorAngles(true)).map(y=>y*100);
        rollMax = Math.max(rollMax, ...ys);
      }
    });
    Object.entries(kdeData.pitch).forEach(([unit, d]) => {
      if (d.data && d.data.length) {
        const ys = kdeOnGridLogBackShift(d.data, xsRoll, getKdeFactorAngles(false)).map(y=>y*100);
        pitchMax = Math.max(pitchMax, ...ys);
      }
    });
    Object.entries(kdeData.freqRoll).forEach(([unit, d]) => {
      if (d.data && d.data.length) {
        const ys = kdeOnGridLogBack(d.data, xsFreq, getKdeFactorFreq()).map(y=>y*100);
        freqRollMax = Math.max(freqRollMax, ...ys);
      }
    });
    Object.entries(kdeData.freqPitch).forEach(([unit, d]) => {
      if (d.data && d.data.length) {
        const ys = kdeOnGridLogBack(d.data, xsFreq, getKdeFactorFreq()).map(y=>y*100);
        freqPitchMax = Math.max(freqPitchMax, ...ys);
      }
    });
    const rollPitchMax = Math.max(10, rollMax, pitchMax) * 1.05;
    const freqMax = Math.max(10, freqRollMax, freqPitchMax) * 1.05;
    // Draw roll and pitch distribs (as before)
    drawKDEMulti('report-kde-roll', kdeData.roll, DEG_RANGE.min, DEG_RANGE.max, DEG_RANGE.gridCnt, getKdeFactorAngles(true), 'Roll (°)', false, colorMap, false, rollPitchMax);
    drawKDEMulti('report-kde-pitch', kdeData.pitch, DEG_RANGE.min, DEG_RANGE.max, DEG_RANGE.gridCnt, getKdeFactorAngles(false), 'Pitch (°)', false, colorMap, false, rollPitchMax);
    // Draw freq distribs using the same style as roll/pitch (linear x axis, kde smoothing, AVG line/label logic)
    drawKDEMulti('report-kde-freq-roll', kdeData.freqRoll, FREQ_RANGE.min, FREQ_RANGE.max, FREQ_RANGE.gridCnt, getKdeFactorFreq(), 'Freq (roll)', false, colorMap, false, freqMax);
    drawKDEMulti('report-kde-freq-pitch', kdeData.freqPitch, FREQ_RANGE.min, FREQ_RANGE.max, FREQ_RANGE.gridCnt, getKdeFactorFreq(), 'Freq (pitch)', false, colorMap, false, freqMax);
    // Add event listeners for show/hide buttons
    document.querySelectorAll('#report-athlete-show button[data-athlete]').forEach(btn => {
      btn.onclick = function() {
        const id = btn.getAttribute('data-athlete');
        rec._athleteShow[id] = !rec._athleteShow[id];
        showReportFor(recId);
      };
    });
  }, 50);
}

// Compute stats for a recording
function computeRecordingStats(rows) {
  if (!rows || !rows.length) return '';
  // Ensure unit settings are loaded
  if (!window.unitSettings) {
    window.unitSettings = JSON.parse(localStorage.getItem('unitColors') || '{}');
  }
  // Group by unit
  const byUnit = {};
  rows.forEach(r => {
    if (!byUnit[r.unit]) byUnit[r.unit] = [];
    byUnit[r.unit].push(r);
  });
  // Get stored unit names and colors
  const unitSettings = JSON.parse(localStorage.getItem('unitColors') || '{}');
  let html = '<div class="row">';
  Object.keys(byUnit).forEach((unit, i) => {
    const arr = byUnit[unit];
    const rolls = arr.map(r => r.roll).filter(Number.isFinite);
    const pitchs = arr.map(r => r.pitch).filter(Number.isFinite);
    const times = arr.map(r => r.t);
    const meanStdRoll = meanStd(rolls);
    const meanStdPitch = meanStd(pitchs);

    // Peak detection and frequency calculation
    const minDist = 300; // ms
    const minProm = 5.0; // deg
    const rPeaks = detectPeaks(rolls, times, minDist, minProm);
    const pPeaks = detectPeaks(pitchs, times, minDist, minProm);

    // Calculate frequencies
    const freq = (peaks) => {
      if(peaks.length < 2) return NaN;
      let s = 0, c = 0;
      for(let i = 1; i < peaks.length; i++) {
        const dt = (peaks[i].t - peaks[i-1].t)/1000;
        if(dt > 0) { s += dt; c++; }
      }
      return c ? 1/(s/c) : NaN;
    };
    const fR = freq(rPeaks);
    const fP = freq(pPeaks);
    
    // Get unit's custom name and color from window.unitSettings
    const storedUnit = window.unitSettings[unit] || {};
    const displayName = storedUnit.customName || unit;
    const displayColor = storedUnit.color || COLORS_BASE[0];
    
    html += `<div class="card half unitStats" style="--ucolor:${displayColor}">`;
    html += `<div style="font-weight:700;margin-bottom:8px;"><span class="unitTag" style="background:${displayColor}">${displayName}</span> — recording stats</div>`;
    html += `<div class="grid">`;
    html += `<div><div class="small">Mean Roll</div><div class="num">${meanStdRoll.mean.toFixed(2)}</div></div>`;
    html += `<div><div class="small">Std Roll</div><div class="num">${meanStdRoll.std.toFixed(2)}</div></div>`;
    html += `<div><div class="small">Mean Pitch</div><div class="num">${meanStdPitch.mean.toFixed(2)}</div></div>`;
    html += `<div><div class="small">Std Pitch</div><div class="num">${meanStdPitch.std.toFixed(2)}</div></div>`;
    html += `<div><div class="small">Peaks Roll</div><div class="num">${rPeaks.length}</div></div>`;
    html += `<div><div class="small">Peaks Pitch</div><div class="num">${pPeaks.length}</div></div>`;
    html += `<div><div class="small">Freq Roll (Hz)</div><div class="num">${isFinite(fR) ? fR.toFixed(2) : '–'}</div></div>`;
    html += `<div><div class="small">Freq Pitch (Hz)</div><div class="num">${isFinite(fP) ? fP.toFixed(2) : '–'}</div></div>`;
    html += `</div></div>`;
  });
  html += '</div>';
  return html;
}

// Draw multi-unit KDE
function drawKDEMulti(canvasId, kdeData, min, max, n, factor, label, logKDE, colorMap, logXAxis, yMaxShared) {
  const el = document.getElementById(canvasId);
  if (!el) return;
  const xs = linspace(min, max, n);
  const datasets = Object.keys(kdeData).map((unit, i) => {
    const data = kdeData[unit].data;
    if (!data.length) return null;
    let ys = logKDE ? kdeOnGridLogBack(data, xs, factor) : kdeOnGridLogBackShift(data, xs, factor);
    ys = ys.map(y=>y*100); // direct KDE percentage
    const storedUnit = window.unitSettings?.[unit] || {};
    return {
      label: storedUnit.customName || unit,
      data: ys,
      borderColor: colorMap[unit] || COLORS_BASE[0],
      backgroundColor: (colorMap[unit] || COLORS_BASE[0]) + '33',
      pointRadius: 0,
      fill: true, // Enable area shading below line
      borderWidth: 2
    };
  }).filter(Boolean);

  // Ensure annotation plugin is registered for every new chart
  if (window['chartjs-plugin-annotation'] && Chart.registry && !Chart.registry.plugins.get('annotation')) {
    Chart.register(window['chartjs-plugin-annotation']);
  }
  // Determine if this is a freq distrib (by canvasId)
  const isFreq = canvasId.includes('freq');
  const freqTicks = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5];
  const chart = new Chart(el.getContext('2d'), {
    type: 'line',
    data: {
      labels: xs.map(x => x.toFixed(2)),
      datasets
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      layout: { padding: { left: 10, right: 10, bottom: 8, top: 4 } },
      plugins: {
        legend: { position: 'bottom', labels: { boxWidth: 10, boxHeight: 10, usePointStyle: true, pointStyle: 'line', color: '#000000' } },
        tooltip: { mode: 'index', intersect: false, callbacks: { label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(2)}%` } },
        annotation: !logXAxis ? red_zero_line() : undefined
      },
      elements: { line: { tension: 0.25, borderWidth: 2 }, point: { radius: 0 } },
      scales: {
        x: isFreq ? {
          type: 'logarithmic',
          title: { display: false },
          min: min,
          max: max,
          grid: { color: '#e0e0e0', tickLength: 4, lineWidth: 1 },
          ticks: {
            color: '#000000',
            padding: 6,
            maxRotation: 0,
            minRotation: 0,
            values: freqTicks,
            callback: function(value) {
              return freqTicks.includes(value) ? value : '';
            }
          }
        }
        : logXAxis ? {
          type: 'logarithmic',
          title: { display: false },
          min: min,
          max: max,
          grid: { color: '#e0e0e0', tickLength: 4, lineWidth: 1 },
          ticks: {
            color: '#000000',
            padding: 6,
            maxRotation: 0,
            minRotation: 0,
            maxTicksLimit: 100,
            callback: function(value) {
              if ([0.01,0.02,0.05,0.1,0.2,0.5,1,2,5].includes(value)) return value;
              return '';
            }
          }
        } : {
          type: 'linear',
          title: { display: false },
          min: min,
          max: max,
          grid: { color: '#e0e0e0', tickLength: 4, lineWidth: 1 },
          ticks: {
            color: '#000000',
            padding: 6,
            maxRotation: 0,
            minRotation: 0,
            stepSize: 10,
            includeBounds: true,
            callback: (v) => String(v)
          }
        },
        y: {
          title: { display: false },
          min: 0,
          max: yMaxShared || undefined,
          grid: { color: '#e0e0e0', tickLength: 4, lineWidth: 1 },
          ticks: { display: false }
        }
      }
    },
    plugins: [window['chartjs-plugin-annotation']].filter(Boolean)
  });

  // Always show AVG line for all athletes in reports
  let showAvgLabel = false;
  const labelBox = document.getElementById('showAvgLabel');
  if (labelBox) showAvgLabel = !!labelBox.checked;

  let avgDebugStr = '';
  let fallbackWarn = false;
  Object.keys(kdeData).forEach(unit => {
    const data = kdeData[unit].data;
    if (!data.length) {
      // Fallback: show gray line at center of x axis
      if (logKDE) {
        const center = (min + max) / 2;
        addAvgLineToDistribChart(chart, center, '#888', 'NO DATA', true, true);
        fallbackWarn = true;
        avgDebugStr += ` | ${unit}: NO DATA`;
      }
      return;
    }
    let ys = logKDE ? kdeOnGridLogBack(data, xs, factor) : kdeOnGridLogBackShift(data, xs, factor);
    ys = ys.map(y=>y*100);
    // For all distribs, use the mean of the raw data for AVG line
    const avg = meanStd(data).mean;
    const color = colorMap[unit] || COLORS_BASE[0];
    if (Number.isFinite(avg)) {
      addAvgLineToDistribChart(chart, avg, color, undefined, true, showAvgLabel);
      avgDebugStr += ` | ${unit}: ${avg.toFixed(2)}`;
    } else if (logKDE) {
      // Fallback: show gray line at center
      const center = (min + max) / 2;
      addAvgLineToDistribChart(chart, center, '#888', 'NO AVG', true, true);
      fallbackWarn = true;
      avgDebugStr += ` | ${unit}: NO AVG`;
    }
  });
  // Set plot title to base only (no stats/debug info)
  const titleEl = el.closest('.card')?.querySelector('div[style*="font-weight:700"]');
  if (titleEl) {
    let baseTitle = titleEl.textContent.split(' | ')[0];
    titleEl.textContent = baseTitle;
    if (fallbackWarn) titleEl.style.color = '#b00';
    else titleEl.style.color = '';
  }
}

// ---------- Tabs ----------
function selectTab(name){
  ['plot','map','reports','settings'].forEach(t=>{
    const el = document.getElementById('tab-'+t);
    if (el) el.classList.add('hidden');
  });
  const showEl = document.getElementById('tab-'+name);
  if (showEl) showEl.classList.remove('hidden');
  document.querySelectorAll('.tabbtn').forEach(x=>x.classList.toggle('active',x.dataset.tab===name));
  if(name==='plot'){
    try{ distCharts.roll.resize();  distCharts.roll.update('none'); }catch{}
    try{ distCharts.pitch.resize(); distCharts.pitch.update('none'); }catch{}
    try{ distCharts.freq.resize();  distCharts.freq.update('none'); }catch{}
  }
  if(name==='map' && map){
    setTimeout(()=>{ map.invalidateSize(); }, 100);
  }
}
document.querySelectorAll('.tabbtn').forEach(b=>b.addEventListener('click',()=>selectTab(b.dataset.tab)));

// ---------- Unit Configuration ----------
document.getElementById('saveUnitConfig')?.addEventListener('click', () => {
  if (saveUnitConfig()) {
    // Apply configurations to all existing units
    Object.keys(units).forEach(unitId => {
      applyUnitConfig(unitId);
    });
  }
});

// ---------- Unlock & connect ----------
document.getElementById('btnUnlock').addEventListener('click',async ()=>{
  const pwd=document.getElementById('pw').value; if(!pwd){document.getElementById('unlockMsg').textContent='Enter a password.';return;}
  if(!ENCRYPTED_CREDS||ENCRYPTED_CREDS==='PASTE_CIPHERTEXT_HERE'){ document.getElementById('unlockMsg').textContent='No encrypted creds embedded.'; return; }
  try{
    const creds=await decryptCreds(pwd,ENCRYPTED_CREDS);
    viewer.user=creds.user; viewer.pass=creds.pass; unlocked=true;
    document.getElementById('gate').classList.add('hidden');
    document.getElementById('app').classList.remove('hidden');
    document.getElementById('maintabs').classList.remove('hidden');
    document.getElementById('btnRecord').classList.remove('hidden');
    document.getElementById('cid').value='web-'+Math.random().toString(16).slice(2,10);

    chartTS=makeTS(); chartSOG=makeSOGChart(); makeMap();

    // init per-athlete distribution charts
    (function initDists(){
  const rctx=document.getElementById('dist-roll').getContext('2d');
  const pctx=document.getElementById('dist-pitch').getContext('2d');
  const frctx=document.getElementById('dist-freq-roll').getContext('2d');
  const fpctx=document.getElementById('dist-freq-pitch').getContext('2d');
  distCharts.roll = makeDensityChartMulti(rctx,'Roll', {min:DEG_RANGE.min,max:DEG_RANGE.max,step:DEG_RANGE.step,type:'linear'});
  distCharts.pitch= makeDensityChartMulti(pctx,'Pitch',{min:DEG_RANGE.min,max:DEG_RANGE.max,step:DEG_RANGE.step,type:'linear'});
  distCharts.freqRoll = makeDensityChartMulti(frctx,'Freq (Roll)',  {min:FREQ_RANGE.min,max:FREQ_RANGE.max,step:FREQ_RANGE.step,type:'logarithmic'});
  distCharts.freqPitch = makeDensityChartMulti(fpctx,'Freq (Pitch)',  {min:FREQ_RANGE.min,max:FREQ_RANGE.max,step:FREQ_RANGE.step,type:'logarithmic'});
  distCharts.xsDeg=null; distCharts.xsHz=null;
    })();

    setStatus('unlocked — not connected',false);
    applyWindow(document.getElementById('winSec').value); applyViewWindow(document.getElementById('viewSec').value);

    // Apply default chart settings
    applyChartDefaults();

    // Race buttons (now live in Settings)
    $('btnTopMark').addEventListener('click', startPlaceTopMark);
    $('btnStartLine').addEventListener('click', startPlaceStartLine);

    if(document.getElementById('autoconn').checked) connect();
  }catch(e){ document.getElementById('unlockMsg').textContent='Wrong password or corrupted ciphertext.'; }
});

function connect(){
  if(!unlocked) return;
  if(client){ try{client.end(true);}catch(e){} client=null; }
  const host=document.getElementById('host').value.trim(), port=document.getElementById('port').value.trim(), path=document.getElementById('path').value.trim()||'/mqtt';
  const topic=document.getElementById('topic').value.trim(), cid=document.getElementById('cid').value||('web-'+Math.random().toString(16).slice(2,10));
  document.getElementById('cid').value=cid; const url=`wss://${host}:${port}${path}`; document.getElementById('url').textContent=url;

  client=mqtt.connect(url,{protocolVersion:4,clean:true,connectTimeout:8000,username:viewer.user,password:viewer.pass,clientId:cid,keepalive:30,resubscribe:true});
  client.on('connect',()=>{
    setStatus('connected',true);
    client.subscribe(topic,{qos:0});
    client.subscribe('m5/marks',{qos:0});
    log('connected & subscribed: '+topic+' and m5/marks');
  });
  client.on('reconnect',()=>{setStatus('reconnecting…',false);log('reconnecting');});
  client.on('close',()=>{setStatus('disconnected',false);log('closed');});
  client.on('error',e=>{setStatus('error',false);log('error: '+(e?.message||e));});
  client.on('message',(topic,payload)=>{
    try{
      const t=Date.now();
      let txt; try{txt=new TextDecoder().decode(payload);}catch{txt=payload.toString?payload.toString():'';}
      const d=JSON.parse(txt);
      if(topic === 'm5/marks') {
        // Handle marks update from replay
        if(typeof d.top_mark_lat === 'number' && typeof d.top_mark_lon === 'number') {
          setTopMark(d.top_mark_lat, d.top_mark_lon);
        }
        if(typeof d.start_pt1_lat === 'number' && typeof d.start_pt1_lon === 'number' && typeof d.start_pt2_lat === 'number' && typeof d.start_pt2_lon === 'number') {
          setStartLine(d.start_pt1_lat, d.start_pt1_lon, d.start_pt2_lat, d.start_pt2_lon);
        }
        log('Received marks update from replay.');
        return;
      }
      let unit=d.unit_id; if(!unit){const m=topic.split('/'); if(m.length>=3) unit=m[1];}
      if(!unit) unit='unknown';
      if(globalT0===null) globalT0=t;

      const u=ensureUnit(unit);

      let roll = d.roll_deg, pitch = d.pitch_deg;
      if(typeof roll !== 'number' || typeof pitch !== 'number') {
        log('msg missing roll/pitch: ' + txt);
        return;
      }

      // raw arrival buffers
      u.times.push(t); u.roll.push(roll); u.pitch.push(pitch);
      if(u.nowElems.roll) u.nowElems.roll.textContent = roll.toFixed(2);
      if(u.nowElems.pitch) u.nowElems.pitch.textContent = pitch.toFixed(2);

      // Handle top mark and start line updates
      if(typeof d.top_mark_lat === 'number' && typeof d.top_mark_lon === 'number') {
        setTopMark(d.top_mark_lat, d.top_mark_lon);
      }
      if(typeof d.start_pt1_lat === 'number' && typeof d.start_pt1_lon === 'number' && typeof d.start_pt2_lat === 'number' && typeof d.start_pt2_lon === 'number') {
        setStartLine(d.start_pt1_lat, d.start_pt1_lon, d.start_pt2_lat, d.start_pt2_lon);
      }

      const lat = coerceNum(d.lat), lon = coerceNum(d.lon);
      const hasFix = validLatLon(lat, lon);
      if(hasFix) {
        u.gnssLatLngs.push([lat, lon]);
        if(u.gnssLatLngs.length > GNSS_KEEP) u.gnssLatLngs.shift();
        u.poly.setLatLngs(u.gnssLatLngs);
        u.poly.setStyle({opacity: u.visible ? 0.95 : 0});
        u.marker.setLatLng([lat, lon]);
        u.marker.setStyle({ opacity: (u.visible ? 1 : 0), fillOpacity: (u.visible ? 1 : 0) });
        if(!firstMapFixDone) fitMapIfFirst(lat, lon);
        if(u.nowElems.ll) u.nowElems.ll.textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;

        updateVelocityFromWindow(u, t, lat, lon);
        if(u.nowElems.sog) u.nowElems.sog.textContent = (u.sogEMA != null) ? u.sogEMA.toFixed(2) : '–';
        if(u.nowElems.hdg) u.nowElems.hdg.textContent = (u.heading != null) ? u.heading.toFixed(0) : '–';
      } else {
        if(u.nowElems.ll) u.nowElems.ll.textContent = '–';
      }

      // record if active
      if(recActive) {
        recRows.push({
          unit,
          t,
          seq: d.seq ?? '',
          roll: (typeof d.roll_deg === 'number' ? d.roll_deg : (typeof d.roll === 'number' ? d.roll : '')),
          pitch: (typeof d.pitch_deg === 'number' ? d.pitch_deg : (typeof d.pitch === 'number' ? d.pitch : '')),
          lat: (hasFix ? lat : ''),
          lon: (hasFix ? lon : ''),
          gnss_ms: d.gnss_ms ?? '',
          gnss_iso: d.gnss_iso ?? '',
          ax: (typeof d.ax === 'number' ? d.ax : ''),
          ay: (typeof d.ay === 'number' ? d.ay : ''),
          az: (typeof d.az === 'number' ? d.az : '')
        });
      }

      // synced plot driver

      chartSOG.update('none');
      recomputePeaks();
      updateAxisRange();

    }catch(e){log('parse error: '+e);}
  });
}

function disconnect(){ if(client){try{client.end(true);}catch(e){} client=null;} setStatus('disconnected',false); log('disconnected'); }
document.getElementById('btnConnect').addEventListener('click',connect);
document.getElementById('btnDisconnect').addEventListener('click',disconnect);
document.getElementById('btnClear').addEventListener('click',()=>{
  for(const id of Object.keys(units)){
    const u=units[id];
    u.times.length=0;u.roll.length=0;u.pitch.length=0;
    u.seriesRoll.length=0;u.seriesPitch.length=0;u.seriesRollPk.length=0;u.seriesPitchPk.length=0;
    u.gnssLatLngs.length=0; u.poly.setLatLngs([]); u.poly.setStyle({opacity:0}); u.marker.setStyle({opacity:0, fillOpacity:0});
    u.lat0=null; u.lon0=null; u.posBuf.length=0; u.sogEMA=null; u.heading=null;
    u.sogTimes.length=0; u.sogVals.length=0; u.sogSeries.length=0;
    u.vmgTimes.length=0; u.vmgVals.length=0; u.vmgSeries.length=0;
    [u.idxRoll,u.idxPitch,u.idxRollPk,u.idxPitchPk].forEach(i=>chartTS.data.datasets[i].hidden=false);
    [u.idxSOG,u.idxVMG].forEach(i=>chartSOG.data.datasets[i].hidden=false);
    if(u.nowElems.dTop) u.nowElems.dTop.textContent='–';
    if(u.nowElems.dStart) u.nowElems.dStart.textContent='–';
  }
  if(distCharts.roll){ for(const ds of distCharts.roll.data.datasets){ ds.data.length=0; ds.hidden=true; } distCharts.roll.update('none'); }
  if(distCharts.pitch){ for(const ds of distCharts.pitch.data.datasets){ ds.data.length=0; ds.hidden=true; } distCharts.pitch.update('none'); }
  if(distCharts.freq){ for(const ds of distCharts.freq.data.datasets){ ds.data.length=0; ds.hidden=true; } distCharts.freq.update('none'); }
  globalT0=null; chartTS.update('none'); chartSOG.update('none'); log('cleared');
  firstMapFixDone=false; if(mapInited) map.setView([0,0],2);
});

// ---------- GNSS guards + geo ----------
function coerceNum(v){
  if(v===null||v===undefined) return null;
  if(typeof v==='string'){
    const s=v.trim().toLowerCase();
    if(s===''||s==='null'||s==='nan'||s==='undefined') return null;
  }
  const n=Number(v); return Number.isFinite(n)? n : null;
}
function validLatLon(lat,lon){return lat!==null&&lon!==null&&Number.isFinite(lat)&&Math.abs(lat)<=90&&Math.abs(lon)<=180;}

// keep axes tight to window and update at 10Hz
setInterval(updateAxisRange,100);

// In case someone presses buttons early (before unlock init)
const btnTM=document.getElementById('btnTopMark'); if(btnTM){ btnTM.addEventListener('click', startPlaceTopMark); }
const btnSL=document.getElementById('btnStartLine'); if(btnSL){ btnSL.addEventListener('click', startPlaceStartLine); }
</script>
</body>
</html>
